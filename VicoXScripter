-- // Key System \\
local function ScriptLoader()
    local request = request or http_request or Krnl.request or syn.request or Fluxus.request

    local function fetchScript(nga)
        local url = nga
        local headers = {["ngrok-skip-browser-warning"] = "true"}
        local response = request({Url = url, Method = "GET", Headers = headers})
        if not response or not response.Body then
            warn("Failed to fetch the script from URL: " .. url)
            return nil
        end
        local success, script = pcall(function() return loadstring(response.Body)() end)
        if not success then
            warn("Failed to execute the script from URL: " .. url .. ", Error: " .. tostring(script))
            return nil
        end
        return script
    end

    local FlurioreLib = fetchScript("https://pastebin.com/raw/2mBP9Q7e")
    if not FlurioreLib then return end
    FlurioreLib:MakeNotify({
        ["Title"] = "VicoX⛅",
        ["Description"] = "",
        ["Color"] = Color3.fromRGB(255, 0, 111),
        ["Content"] = "Updated...",
        ["Time"] = 1,
        ["Delay"] = 5
    })

    local Helper = fetchScript("https://pastebin.com/raw/3M42Ukj4")
    if not Helper then return end

    local crypter = fetchScript("https://raw.githubusercontent.com/Egor-Skriptunoff/pure_lua_SHA/master/sha2.lua")
    if not crypter then return end

    setfpscap(100)

    local LocalPlayer = game.Players.LocalPlayer
    if not game:IsLoaded() then game.Loaded:Wait() end

    local ReplicatedStorage = cloneref(game:GetService('ReplicatedStorage')) -- Perbaikan nama service
    local RbxAnalyticsService = cloneref(game:GetService('RbxAnalyticsService'))
    local UserInputService = cloneref(game:GetService('UserInputService'))
    local NetworkClient = cloneref(game:GetService("NetworkClient"))
    local TweenService = cloneref(game:GetService('TweenService'))
    local VirtualUser = cloneref(game:GetService('VirtualUser'))
    local HttpService = cloneref(game:GetService('HttpService'))
    local RunService = cloneref(game:GetService('RunService'))
    local LogService = cloneref(game:GetService('LogService'))
    local Lighting = cloneref(game:GetService('Lighting'))
    local CoreGui = cloneref(game:GetService('CoreGui'))
    local Players = cloneref(game:GetService('Players'))
    local Debris = cloneref(game:GetService('Debris'))
    local Stats = cloneref(game:GetService('Stats'))
    local uis = game:GetService("UserInputService")

    local client_id = RbxAnalyticsService:GetClientId()
    local names_map = {
        ['protected'] = crypter.sha3_384(client_id, 'sha3-256'),
        ['Pillow'] = crypter.sha3_384(client_id .. 'Pillow', 'sha3-256'),
        ['Touhou'] = crypter.sha3_384(client_id .. 'Touhou', 'sha3-256'),
        ['Shion'] = crypter.sha3_384(client_id .. 'Shion', 'sha3-256'),
        ['Miku'] = crypter.sha3_384(client_id .. 'Miku', 'sha3-256'),
        ['Sino'] = crypter.sha3_384(client_id .. 'Sino', 'sha3-256'),
        ['Soi'] = crypter.sha3_384(client_id .. 'Soi', 'sha3-256')
    }

    local assets = game:GetObjects('rbxassetid://98657300657778')[1]
    assets.Parent = ReplicatedStorage -- Perbaikan nama service
    assets.Name = names_map['protected']

    -- Pengecekan struktur assets
    local effects_folder = assets:FindFirstChild("effects") or Instance.new("Folder", assets)
    effects_folder.Name = "effects"
    local objects_folder = assets:FindFirstChild("objects") or Instance.new("Folder", assets)
    objects_folder.Name = "objects"
    local sounds_folder = assets:FindFirstChild("sounds") or Instance.new("Folder", assets)
    sounds_folder.Name = "sounds"
    local gui_folder = assets:FindFirstChild("gui") or Instance.new("Folder", assets)
    gui_folder.Name = "gui"

    local RunTime = workspace.Runtime
    local Alive = workspace.Alive
    local Dead = workspace.Dead

    local AutoParry = {
        ball = {
            training_ball_entity = nil,
            client_ball_entity = nil,
            ball_entity = nil,
            properties = {
                last_ball_pos = Vector3.new(0, 0, 0),
                aero_dynamic_time = tick(),
                hell_hook_completed = true,
                last_position = Vector3.new(0, 0, 0),
                rotation = Vector3.new(0, 0, 0),
                position = Vector3.new(0, 0, 0),
                last_warping = tick(),
                parry_remote = nil,
                is_curved = false,
                last_tick = tick(),
                auto_spam = false,
                cooldown = false,
                respawn_time = 0,
                parry_range = 0,
                spam_range = 0,
                maximum_speed = 0,
                old_speed = 0,
                parries = 0,
                direction = 0,
                distance = 0,
                velocity = 0,
                last_hit = 0,
                lerp_radians = 0,
                radians = 0,
                speed = 0,
                dot = 0
            }
        },
        target = {
            current = nil,
            from = nil,
            aim = nil,
        },
        entity_properties = {
            server_position = Vector3.new(0, 0, 0),
            velocity = Vector3.new(0, 0, 0),
            is_moving = false,
            direction = 0,
            distance = 0,
            speed = 0,
            dot = 0
        }
    }

    local Player = {
        Entity = {
            properties = {
                sword = '',
                server_position = Vector3.new(0, 0, 0),
                velocity = Vector3.new(0, 0, 0),
                position = Vector3.new(0, 0, 0),
                is_moving = false,
                speed = 0,
                ping = 1
            }
        },
        properties = {
            grab_animation = nil
        }
    }

    local World = {}

    function create_animation(object, info, value)
        local animation = TweenService:Create(object, info, value)
        animation:Play()
        task.wait(info.Time)
        Debris:AddItem(animation, 0)
        animation:Destroy()
        animation = nil
    end

    function linear_predict(a, b, time_volume)
        return a + (b - a) * time_volume
    end

    function World:get_pointer()
        local mouse_location = UserInputService:GetMouseLocation()
        local ray = workspace.CurrentCamera:ScreenPointToRay(mouse_location.X, mouse_location.Y, 0)
        return CFrame.lookAt(ray.Origin, ray.Origin + ray.Direction)
    end

    function AutoParry.get_ball()
        for _, ball in workspace.Balls:GetChildren() do
            if ball:GetAttribute("realBall") then
                return ball
            end
        end
        return nil
    end

    function AutoParry.get_client_ball()
        for _, ball in workspace.Balls:GetChildren() do
            if not ball:GetAttribute("realBall") then
                return ball
            end
        end
        return nil
    end

    function makingtrail()
        local ball = Helper.getBall()
        if not ball then return end

        local function createOrUpdateTrail()
            local Trail = ball:FindFirstChild("Trail")
            if not Trail then
                Trail = Instance.new("Trail")
                Trail.Name = "Trail"
                Trail.FaceCamera = true
                Trail.Parent = ball
            end

            local At1 = ball:FindFirstChild("at1")
            local At2 = ball:FindFirstChild("at2")

            if At1 and At2 then
                Trail.Attachment0 = At1
                Trail.Attachment1 = At2
                Trail.Color = ColorSequence.new{
                    ColorSequenceKeypoint.new(0.00, Color3.new(1.00, 0.00, 0.02)),
                    ColorSequenceKeypoint.new(0.14, Color3.new(0.98, 1.00, 0.00)),
                    ColorSequenceKeypoint.new(0.30, Color3.new(0.07, 1.00, 0.00)),
                    ColorSequenceKeypoint.new(0.48, Color3.new(0.00, 0.98, 1.00)),
                    ColorSequenceKeypoint.new(0.69, Color3.new(0.03, 0.00, 1.00)),
                    ColorSequenceKeypoint.new(0.88, Color3.new(1.00, 0.00, 0.98)),
                    ColorSequenceKeypoint.new(1.00, Color3.new(1.00, 0.00, 0.02))
                }
                Trail.WidthScale = NumberSequence.new{
                    NumberSequenceKeypoint.new(0.00, 0.5, 0.00),
                    NumberSequenceKeypoint.new(1.00, 0.00, 0.00)
                }
                Trail.Transparency = NumberSequence.new{
                    NumberSequenceKeypoint.new(0.00, 0.00, 0.00),
                    NumberSequenceKeypoint.new(1.00, 1.00, 0.00)
                }
                Trail.Enabled = true
            end
        end

        local function enableTrailAndDisableFF()
            createOrUpdateTrail()
            local Trail = ball:FindFirstChild("Trail")
            if Trail then Trail.Enabled = true end
            local ff = ball:FindFirstChild("ff")
            if ff then ff.Enabled = false end
        end

        local function disableTrailAndEnableFF()
            local Trail = ball:FindFirstChild("Trail")
            if Trail then Trail:Destroy() end
            local ff = ball:FindFirstChild("ff")
            if ff then ff.Enabled = true end
        end

        if ball_trial_Enabled then
            enableTrailAndDisableFF()
        else
            disableTrailAndEnableFF()
        end
    end

    local Visualize = Instance.new("Part", workspace)
    Visualize.Color = Color3.new(1, 1, 1)
    Visualize.Material = Enum.Material.ForceField
    Visualize.Transparency = 0.5
    Visualize.Anchored = true
    Visualize.CanCollide = false
    Visualize.CastShadow = false
    Visualize.Shape = Enum.PartType.Ball
    Visualize.Size = Vector3.new(30, 30, 30)
    local Popobd = Instance.new("Part", workspace)
    Popobd.Color = Color3.new(1, 0, 1)
    Popobd.Material = Enum.Material.ForceField
    Popobd.Transparency = 0.5
    Popobd.Anchored = true
    Popobd.CanCollide = false
    Popobd.CastShadow = false
    Popobd.Shape = Enum.PartType.Ball
    Popobd.Size = Vector3.new(30, 30, 30)
    local jihag = Instance.new("Part", workspace)
    jihag.Color = Color3.new(0, 0, 1)
    jihag.Material = Enum.Material.ForceField
    jihag.Transparency = 0.5
    jihag.Anchored = true
    jihag.CanCollide = false
    jihag.CastShadow = false
    jihag.Shape = Enum.PartType.Ball
    jihag.Size = Vector3.new(30, 30, 30)
    local Popobdm = Instance.new("Highlight")
    Popobdm.Parent = Popobd
    Popobdm.Enabled = true
    Popobdm.FillTransparency = 0
    Popobdm.OutlineColor = Color3.new(1, 1, 1)
    local jihagm = Instance.new("Highlight")
    jihagm.Parent = jihag
    jihagm.Enabled = true
    jihagm.FillTransparency = 0
    jihagm.OutlineColor = Color3.new(1, 1, 1)
    local Highlight = Instance.new("Highlight")
    Highlight.Parent = Visualize
    Highlight.Enabled = true
    Highlight.FillTransparency = 0
    Highlight.OutlineColor = Color3.new(1, 1, 1)

    local nowprediction = true
    local auto_parry_enabled = false
    local personnel_detector_enabled = true
    local ball_trial_Enabled = false
    local strength = 0
    local gravity_enabled = false
    local current_curve = nil
    local ai_Enabled = false
    local auto_win = false
    local tp_hit = false
    local visualize_Enabled = false
    local parry_mode = "Rage"
    local speeddo = 3
    local skibidispam = false
    local anticurveskibi = false

    function AutoParry.get_parry_remote()
        local Services = {game:GetService("VirtualUser"), game:GetService('VirtualInputManager')}
        for _, v in pairs(Services) do
            local temp_remote = v:FindFirstChildOfClass('RemoteEvent')
            if temp_remote and temp_remote.Name:find('\n') then
                AutoParry.ball.properties.parry_remote = temp_remote
            end
        end
    end

    AutoParry.get_parry_remote()

    function AutoParry.perform_grab_animation()
        local animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
        local currently_equipped = Player.Entity.properties.sword
        if not currently_equipped or currently_equipped == 'Titan Blade' or not animation then return end
        local sword_data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(currently_equipped)
        if not sword_data or not sword_data['AnimationType'] then return end
        local character = LocalPlayer.Character
        if not character or not character:FindFirstChild('Humanoid') then return end
        for _, object in ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren() do
            if object.Name ~= sword_data['AnimationType'] then continue end
            if not (object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab')) then continue end
            local sword_animation_type = 'GrabParry'
            if object:FindFirstChild('Grab') then sword_animation_type = 'Grab' end
            animation = object[sword_animation_type]
        end
        Player.properties.grab_animation = character.Humanoid:LoadAnimation(animation)
        Player.properties.grab_animation:Play()
    end

    function AutoParry.perform_parry()
        local ball_properties = AutoParry.ball.properties
        if ball_properties.cooldown and not ball_properties.auto_spam then return end
        ball_properties.parries += 1
        ball_properties.last_hit = tick()
        local camera = workspace.CurrentCamera
        local direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, AutoParry.entity_properties.server_position)
        if not ball_properties.auto_spam then
            AutoParry.perform_grab_animation()
            ball_properties.cooldown = true
            if current_curve then
                direction = CFrame.new(LocalPlayer.Character.PrimaryPart.Position, AutoParry.entity_properties.server_position + Vector3.new(0, 150, 0))
            end
        else
            direction = CFrame.new(camera.CFrame.Position, AutoParry.entity_properties.server_position + Vector3.new(0, 60, 0))
            ball_properties.parry_remote:FireServer(0, direction, {[AutoParry.target.aim.Name] = AutoParry.entity_properties.server_position}, {AutoParry.entity_properties.server_position.X, AutoParry.entity_properties.server_position.Y}, false)
            task.delay(1, function() if ball_properties.parries > 0 then ball_properties.parries -= 1 end end)
            return
        end
        ball_properties.parry_remote:FireServer(0.5, direction, {[AutoParry.target.aim.Name] = AutoParry.entity_properties.server_position}, {AutoParry.entity_properties.server_position.X, AutoParry.entity_properties.server_position.Y}, false)
        task.delay(0.5, function() if ball_properties.parries > 0 then ball_properties.parries -= 1 end end)
    end

    function AutoParry.reset()
        nowprediction = true
        AutoParry.ball.properties.is_curved = false
        AutoParry.ball.properties.auto_spam = false
        AutoParry.ball.properties.cooldown = false
        AutoParry.ball.properties.maximum_speed = 0
        AutoParry.ball.properties.parries = 0
        AutoParry.entity_properties.server_position = Vector3.new(0, 0, 0)
        AutoParry.target.current = nil
        AutoParry.target.from = nil
    end

    ReplicatedStorage.Remotes.PlrHellHooked.OnClientEvent:Connect(function(hooker)
        if hooker.Name == LocalPlayer.Name then
            AutoParry.ball.properties.hell_hook_completed = true
            return
        end
        AutoParry.ball.properties.hell_hook_completed = false
    end)

    ReplicatedStorage.Remotes.PlrHellHookCompleted.OnClientEvent:Connect(function()
        AutoParry.ball.properties.hell_hook_completed = true
    end)

    function AutoParry.is_curved()
        if not anticurveskibi then return false end
        local target = AutoParry.target.current
        if not target then return false end
        local ball_properties = AutoParry.ball.properties
        if target.PrimaryPart:FindFirstChild('MaxShield') and AutoParry.target.current.Name ~= LocalPlayer.Name and ball_properties.distance < 50 then return false end
        if AutoParry.ball.ball_entity:FindFirstChild('TimeHole1') and AutoParry.target.current.Name ~= LocalPlayer.Name and ball_properties.distance < 100 then
            ball_properties.auto_spam = false
            return false
        end
        if AutoParry.ball.ball_entity:FindFirstChild('WEMAZOOKIEGO') and AutoParry.target.current.Name ~= LocalPlayer.Name and ball_properties.distance < 100 then return false end
        if AutoParry.ball.ball_entity:FindFirstChild('At2') and ball_properties.speed <= 0 then return true end
        if AutoParry.ball.ball_entity:FindFirstChild('AeroDynamicSlashVFX') then
            Debris:AddItem(AutoParry.ball.ball_entity.AeroDynamicSlashVFX, 0)
            ball_properties.auto_spam = false
            ball_properties.aero_dynamic_time = tick()
        end
        if RunTime:FindFirstChild('Tornado') then
            if ball_properties.distance > 5 and (tick() - ball_properties.aero_dynamic_time) < (RunTime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then return true end
        end
        if not ball_properties.hell_hook_completed and target.Name == LocalPlayer.Name and ball_properties.distance > 5 - math.random() then return true end
        local ball_direction = ball_properties.velocity.Unit
        local ball_speed = ball_properties.speed
        local speed_threshold = math.min(ball_speed / 100, 40)
        local angle_threshold = 40 * math.max(ball_properties.dot, 0)
        local player_ping = Player.Entity.properties.ping
        local accurate_direction = ball_properties.velocity.Unit * ball_direction
        local direction_difference = (accurate_direction - ball_properties.velocity).Unit
        local accurate_dot = ball_properties.direction:Dot(direction_difference)
        local dot_difference = ball_properties.dot - accurate_dot
        local dot_threshold = 0.5 - player_ping / 1000
        local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)
        local enough_speed = ball_properties.maximum_speed > 100
        local ball_distance_threshold = 15 - math.min(ball_properties.distance / 1000, 15) + angle_threshold + speed_threshold
        if enough_speed and reach_time > player_ping / 10 then ball_distance_threshold = math.max(ball_distance_threshold - 15, 15) end
        if ball_properties.distance < ball_distance_threshold then return false end
        if dot_difference < dot_threshold then return true end
        if ball_properties.lerp_radians < 0.018 then
            ball_properties.last_curve_position = ball_properties.position
            ball_properties.last_warping = tick()
        end
        if (tick() - ball_properties.last_warping) < (reach_time / 1.5) then return true end
        return ball_properties.dot < dot_threshold
    end

    function AutoParry:is_spam()
        if not skibidispam then return false end
        local target = AutoParry.target.current
        if not target then return false end
        if AutoParry.target.from ~= LocalPlayer.Character then old_from_target = AutoParry.target.from end
        local ball_properties = AutoParry.ball.properties
        local player_ping = Player.Entity.properties.ping
        local distance_threshold = (ball_properties.spam_accuracy / 2.5) + (player_ping / 80)
        local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)
        if (tick() - ball_properties.last_hit) > 0.8 and ball_properties.distance > distance_threshold and ball_properties.parries < 3 then
            ball_properties.parries = 1
            return false
        end
        if ball_properties.lerp_radians > 0.028 then
            if ball_properties.parries > 2 then ball_properties.parries = 1 end
            return false
        end
        if (tick() - ball_properties.last_warping) < (reach_time / 1.3) and ball_properties.distance > distance_threshold and ball_properties.parries < 4 then
            if ball_properties.parries > 3 then ball_properties.parries = 1 end
            return false
        end
        if math.abs(ball_properties.speed - ball_properties.old_speed) < 5.2 and ball_properties.distance > distance_threshold and ball_properties.speed < 60 and ball_properties.parries < 3 then
            if ball_properties.parries > 3 then ball_properties.parries = 0 end
            return false
        end
        if ball_properties.speed < 10 then
            ball_properties.parries = 1
            return false
        end
        if ball_properties.maximum_speed < ball_properties.speed and ball_properties.distance > distance_threshold then
            ball_properties.parries = 1
            return false
        end
        if ball_properties.distance > ball_properties.spam_range and ball_properties.distance > distance_threshold then
            if ball_properties.parries > 2 then ball_properties.parries = 1 end
            return false
        end
        if ball_properties.distance > ball_properties.spam_accuracy and ball_properties.distance > distance_threshold then
            if ball_properties.parries > 3 then ball_properties.parries = 2 end
            return false
        end
        return true
    end

    function Player:get_aim_entity()
        local closest_entity = nil
        local minimal_dot_product = -math.huge
        local camera_direction = workspace.CurrentCamera.CFrame.LookVector
        for _, player in Alive:GetChildren() do
            if not player or player.Name == LocalPlayer.Name or not player:FindFirstChild('HumanoidRootPart') then continue end
            local entity_direction = (player.HumanoidRootPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
            local dot_product = camera_direction:Dot(entity_direction)
            if dot_product > minimal_dot_product then
                minimal_dot_product = dot_product
                closest_entity = player
            end
        end
        return closest_entity
    end

    function Player:get_closest_player_to_cursor()
        local closest_player = nil
        local minimal_dot_product = -math.huge
        for _, player in workspace.Alive:GetChildren() do
            if player == LocalPlayer.Character or player.Parent ~= Alive then continue end
            local player_direction = (player.PrimaryPart.Position - workspace.CurrentCamera.CFrame.Position).Unit
            local pointer = World.get_pointer()
            local dot_product = pointer.LookVector:Dot(player_direction)
            if dot_product > minimal_dot_product then
                minimal_dot_product = dot_product
                closest_player = player
            end
        end
        return closest_player
    end

    function Player:claim_rewards()
        repeat task.wait(1) until not AutoParry.ball.properties.auto_spam
        local net = ReplicatedStorage:WaitForChild("Packages")['_Index']['sleitnick_net@0.1.0'].net
        ReplicatedStorage:WaitForChild("Remote"):WaitForChild("RemoteEvent"):FireServer('ClaimLoginReward')
        task.defer(function()
            for day = 1, 30 do
                task.wait()
                ReplicatedStorage.Remote.RemoteFunction:InvokeServer('ClaimNewDailyLoginReward', day)
                net:WaitForChild("RE/SummerWheel/ProcessRoll"):FireServer()
                net:WaitForChild("RE/SummerWheel/ClaimReward"):FireServer()
                net:WaitForChild("RE/ProcessTournamentEventRoll"):FireServer()
                net:WaitForChild("RE/CyborgWheel/ProcessRoll"):FireServer()
                net:WaitForChild("RE/SynthWheel/ProcessRoll"):FireServer()
                net:WaitForChild("RE/ProcessTournamentRoll"):FireServer()
                net:WaitForChild("RE/RolledReturnCrate"):FireServer()
                net:WaitForChild("RE/ProcessLTMRoll"):FireServer()
            end
        end)
        task.defer(function()
            for reward = 1, 6 do
                net:WaitForChild("RF/ClaimPlaytimeReward"):InvokeServer(reward)
                net:WaitForChild("RE/ClaimSeasonPlaytimeReward"):FireServer(reward)
                ReplicatedStorage:WaitForChild("Remote"):WaitForChild("RemoteFunction"):InvokeServer('SpinWheel')
                net:WaitForChild("RE/SpinFinished"):FireServer()
            end
        end)
        task.defer(function()
            for reward = 1, 5 do
                net:WaitForChild("RF/RedeemQuestsType"):InvokeServer('SummerClashEvent', 'Daily', reward)
            end
        end)
        task.defer(function()
            for reward = 1, 4 do
                net:WaitForChild("RE/SummerWheel/ClaimStreakReward"):FireServer(reward)
            end
        end)
    end

    RunService:BindToRenderStep('server position simulation', 1, function()
        local ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
        if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then return end
        local PrimaryPart = LocalPlayer.Character.PrimaryPart
        local old_position = PrimaryPart.Position
        task.delay(ping / 1000, function() Player.Entity.properties.server_position = old_position end)
    end)

    RunService.PreSimulation:Connect(function()
        NetworkClient:SetOutgoingKBPSLimit(math.huge)
        local character = LocalPlayer.Character
        if not character or not character.PrimaryPart then return end
        local player_properties = Player.Entity.properties
        player_properties.sword = character:GetAttribute('CurrentlyEquippedSword')
        player_properties.ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
        player_properties.velocity = character.PrimaryPart.AssemblyLinearVelocity
        player_properties.speed = player_properties.velocity.Magnitude
        player_properties.is_moving = player_properties.speed > 30
    end)

    AutoParry.ball.ball_entity = AutoParry.get_ball()
    AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()

    RunService.PreSimulation:Connect(function()
        local ball = AutoParry.ball.ball_entity
        if not ball then return end
        local zoomies = ball:FindFirstChild('zoomies')
        local ball_properties = AutoParry.ball.properties
        ball_properties.position = ball.Position
        ball_properties.velocity = ball.AssemblyLinearVelocity
        if zoomies then ball_properties.velocity = ball.zoomies.VectorVelocity end
        ball_properties.distance = (Player.Entity.properties.server_position - ball_properties.position).Magnitude
        ball_properties.speed = ball_properties.velocity.Magnitude
        ball_properties.direction = (Player.Entity.properties.server_position - ball_properties.position).Unit
        ball_properties.dot = ball_properties.direction:Dot(ball_properties.velocity.Unit)
        ball_properties.radians = math.rad(math.asin(ball_properties.dot))
        ball_properties.lerp_radians = linear_predict(ball_properties.lerp_radians, ball_properties.radians, 0.8)
        if not (ball_properties.lerp_radians < 0) and not (ball_properties.lerp_radians > 0) then ball_properties.lerp_radians = 0.027 end
        ball_properties.maximum_speed = math.max(ball_properties.speed, ball_properties.maximum_speed)
        AutoParry.target.aim = (not uis.TouchEnabled and Player.get_closest_player_to_cursor() or Player.get_aim_entity())
        if ball:GetAttribute('from') then AutoParry.target.from = Alive:FindFirstChild(ball:GetAttribute('from')) end
        AutoParry.target.current = Alive:FindFirstChild(ball:GetAttribute('target'))
        if not AutoParry.target.current then return end
        ball_properties.rotation = ball_properties.position
        if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
            ball_properties.rotation = AutoParry.target.aim.PrimaryPart.Position
            return
        end
        local target_server_position = AutoParry.target.current.PrimaryPart.Position
        local target_velocity = AutoParry.target.current.PrimaryPart.AssemblyLinearVelocity
        AutoParry.entity_properties.server_position = target_server_position
        AutoParry.entity_properties.velocity = target_velocity
        AutoParry.entity_properties.distance = LocalPlayer:DistanceFromCharacter(target_server_position)
        AutoParry.entity_properties.direction = (Player.Entity.properties.server_position - target_server_position).Unit
        AutoParry.entity_properties.speed = target_velocity.Magnitude
        AutoParry.entity_properties.is_moving = target_velocity.Magnitude > 0.1
        AutoParry.entity_properties.dot = AutoParry.entity_properties.is_moving and math.max(AutoParry.entity_properties.direction:Dot(target_velocity.Unit), 0)

        -- Visualisasi
        if visualize_Enabled and LocalPlayer.Character then
            Visualize.Transparency = 0
            Visualize.Size = Vector3.new(ball_properties.parry_range, ball_properties.parry_range, ball_properties.parry_range)
            Visualize.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
            Popobd.Transparency = 0
            Popobd.Size = Vector3.new(ball_properties.distance, ball_properties.distance, ball_properties.distance)
            Popobd.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
            jihag.Transparency = 0
            jihag.Size = Vector3.new(ball_properties.speed, ball_properties.speed, ball_properties.speed)
            jihag.CFrame = CFrame.new(LocalPlayer.Character.PrimaryPart.Position)
        else
            Visualize.Transparency = 1
            Popobd.Transparency = 1
            jihag.Transparency = 1
        end
        if ball_properties.auto_spam then
            Visualize.Color = Color3.new(1, 0, 0)
            Visualize.Size = Vector3.new(30, 30, 30)
        elseif not (AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character) then
            Visualize.Color = Color3.new(0, 1, 0)
            Visualize.Size = Vector3.new(ball_properties.parry_range, ball_properties.parry_range, ball_properties.parry_range)
        elseif ball_properties.distance < ball_properties.parry_range then
            Visualize.Color = Color3.new(0, 0, 0)
            Visualize.Size = Vector3.new(ball_properties.parry_range, ball_properties.parry_range, ball_properties.parry_range)
        else
            Visualize.Color = Color3.new(1, 1, 1)
        end

        -- Auto Parry Logic
        if not auto_parry_enabled then
            AutoParry.reset()
            return
        end
        if not AutoParry.ball.ball_entity or LocalPlayer.Character.Parent == Dead then
            AutoParry.reset()
            return
        end
        ball_properties.is_curved = AutoParry.is_curved()
        local baseMoveAmount = 0.48
        local moveAmount = baseMoveAmount * (1 / (AutoParry.entity_properties.distance + 0.01)) * 1000
        local ping_threshold = math.clamp(Player.Entity.properties.ping / 10, 10, 16)
        local spam_accuracy = math.min(moveAmount + (ball_properties.speed / 8.4), 150 + moveAmount) + ping_threshold
        local parry_accuracy = ball_properties.maximum_speed / 10.8 + ping_threshold
        if player_properties.is_moving then parry_accuracy *= 1.1 end
        if Player.Entity.properties.ping >= 190 then parry_accuracy = parry_accuracy * (1 + (Player.Entity.properties.ping / 500)) end
        ball_properties.spam_range = ping_threshold + ball_properties.speed / 2.38
        ball_properties.parry_range = (ping_threshold + ball_properties.speed) * 1.53 / math.pi
        if Player.Entity.properties.sword == 'Titan Blade' then
            ball_properties.parry_range += 11
            ball_properties.spam_range += 2
        end
        local distance_to_last_position = LocalPlayer:DistanceFromCharacter(ball_properties.last_position)
        if ball_properties.auto_spam and AutoParry.target.current then
            ball_properties.auto_spam = AutoParry:is_spam()
        end
        if ball_properties.auto_spam then return end
        if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
            ball_properties.auto_spam = AutoParry:is_spam()
        end
        if ball_properties.auto_spam then return end
        if ball_properties.is_curved then return end
        if ball_properties.distance > ball_properties.parry_range and ball_properties.distance > parry_accuracy then return end
        if AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character then return end
        local target_Ball_Distance = (ball_properties.position - AutoParry.entity_properties.server_position).Magnitude
        if parry_mode == "Legit" then
            if target_Ball_Distance <= 10 and AutoParry.entity_properties.distance <= 50 then
                if math.random(1, 2) == 1 then AutoParry.perform_parry() end
            end
            if ball_properties.maximum_speed >= 250 then parry_accuracy *= 1.2 end
        end
        ball_properties.last_ball_pos = ball_properties.position
        AutoParry.perform_parry()
        task.spawn(function()
            repeat RunService.PreSimulation:Wait(0) until (tick() - ball_properties.last_hit) > 1 - (ping_threshold / 100)
            ball_properties.cooldown = false
        end)
    end)

    RunService.PreSimulation:Connect(function()
        if AutoParry.ball.properties.auto_spam then
            for v = 1, speeddo do AutoParry.perform_parry() end
        end
    end)

    ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(slash, root)
        task.spawn(function()
            if root.Parent and root.Parent ~= LocalPlayer.Character and root.Parent.Parent == Alive then
                AutoParry.ball.properties.cooldown = false
            end
        end)
        if AutoParry.ball.properties.auto_spam then
            for v = 1, speeddo do AutoParry.perform_parry() end
        end
        if AutoParry.target.current ~= LocalPlayer.Name then nowprediction = true end
    end)

    ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
        if LocalPlayer.Character.Parent ~= Alive or not Player.properties.grab_animation then return end
        Player.properties.grab_animation:Stop()
        local ball = AutoParry.get_client_ball()
        if ball and AutoParry.ball.properties.auto_spam then
            for v = 1, speeddo do AutoParry.perform_parry() end
        end
    end)

    RunService.PostSimulation:Connect(function()
        if not gravity_enabled then workspace.Gravity = 196.2 return end
        workspace.Gravity = 196.2 / (strength / 10)
    end)

    local function clear_skyboxes()
        for _, child in Lighting:GetChildren() do
            if child:IsA('Sky') then Debris:AddItem(child, 0) end
        end
    end

    local staff_roles = {'content creator', 'contributor', 'trial qa', 'tester', 'mod'}
    Players.PlayerAdded:Connect(function(player)
        if not personnel_detector_enabled then return end
        local player_role = tostring(player:GetRoleInGroup(12836673)):lower()
        if table.find(staff_roles, player_role) then game:Shutdown() end
    end)

    local is_respawned = false
    workspace.Balls.ChildRemoved:Connect(function(child)
        is_respawned = false
        if child == AutoParry.ball.ball_entity then
            AutoParry.ball.ball_entity = nil
            AutoParry.ball.client_ball_entity = nil
            AutoParry.reset()
        end
    end)

    workspace.Balls.ChildAdded:Connect(function()
        if is_respawned then return end
        is_respawned = true
        local ball_properties = AutoParry.ball.properties
        ball_properties.respawn_time = tick()
        AutoParry.ball.ball_entity = AutoParry.get_ball()
        AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()
        local target = AutoParry.ball.ball_entity:GetAttribute('target')
        AutoParry.ball.ball_entity:GetAttributeChangedSignal('target'):Connect(function()
            if target == LocalPlayer.Name then
                ball_properties.cooldown = false
                return
            end
            ball_properties.cooldown = false
            ball_properties.old_speed = ball_properties.speed
            ball_properties.last_position = ball_properties.position
            ball_properties.parries += 1
            task.delay(1, function() if ball_properties.parries > 0 then ball_properties.parries -= 1 end end)
        end)
    end)

    local function optimizer()
        Lighting.GlobalShadows = false
        Lighting.Brightness = 0
        workspace.LevelOfDetail = Enum.LevelOfDetailSetting.Low
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Part") or v:IsA("MeshPart") then
                v.Material = Enum.Material.SmoothPlastic
                v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then
                v.Transparency = 1
            elseif v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Fire") then
                v.Enabled = false
            end
        end
        Lighting.FogEnd = 9e9
    end

    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    local TextLabel = Instance.new("TextLabel")
    TextLabel.Parent = ScreenGui
    TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    TextLabel.BackgroundTransparency = 1.000
    TextLabel.BorderSizePixel = 0
    TextLabel.Position = UDim2.new(0.359138072, 0, -0.025062656, 0)
    TextLabel.Size = UDim2.new(0, 200, 0, 50)
    TextLabel.Font = Enum.Font.FredokaOne
    TextLabel.Text = "https://discord.com/invite/PvZX8BJKbS"
    TextLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    TextLabel.TextSize = 19.000
    local UIGradient = Instance.new("UIGradient")
    UIGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(0.01, Color3.fromRGB(23, 48, 235)),
        ColorSequenceKeypoint.new(0.16, Color3.fromRGB(55, 23, 235)),
        ColorSequenceKeypoint.new(0.35, Color3.fromRGB(219, 13, 30)),
        ColorSequenceKeypoint.new(0.68, Color3.fromRGB(8, 152, 255)),
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(114, 187, 255))
    }
    UIGradient.Parent = TextLabel

    Fluent = fetchScript("https://pastebin.com/raw/ijLKzE19")
    if not Fluent then return end
    Window = Fluent:CreateWindow({
        Title = "WaverHub⛅",
        SubTitle = "Made By Josh and helped by CBB/REN",
        TabWidth = 120,
        Size = UDim2.fromOffset(490, 320),
        Acrylic = false,
        Theme = "Acrylic",
        MinimizeKey = Enum.KeyCode.LeftControl
    })
    Tabs = {
        Main = Window:AddTab({Title = "Combat", Icon = ""}),
        Mina = Window:AddTab({Title = "Visual", Icon = ""}),
        Credits = Window:AddTab({Title = "Credits", Icon = ""})
    }

    do
        local auto_parry = Tabs.Main:AddToggle("ap", {
            Title = "Auto Parry",
            Description = "Main Auto Parry",
            Default = false,
        })
        auto_parry:OnChanged(function(v) auto_parry_enabled = v end)
        local curve_metho = Tabs.Main:AddToggle("am", {
            Title = "Auto Spam",
            Description = "Toggle Auto Spam",
            Default = false,
        })
        curve_metho:OnChanged(function(v) skibidispam = v end)
        local curve_meho = Tabs.Main:AddToggle("aa", {
            Title = "Anti Curve",
            Description = "(Recommended, Dont Turn Off)",
            Default = true,
        })
        curve_meho:OnChanged(function(v) anticurveskibi = v end)
        local curve_method2 = Tabs.Main:AddToggle("cm", {
            Title = "Curve Ball",
            Description = "Curve The Ball",
            Default = false,
        })
        curve_method2:OnChanged(function(v) current_curve = v end)
        local Dropdown = Tabs.Main:AddDropdown("pdown", {
            Title = "Auto Parry Mode",
            Values = {"Legit", "Blatant"},
            Multi = false,
            Default = "Blatant",
        })
        Dropdown:SetValue("Blatant")
        Dropdown:OnChanged(function(Value) parry_mode = Value end)
        local Dropddown = Tabs.Main:AddDropdown("pdowdn", {
            Title = "Spam Speed",
            Values = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10"},
            Multi = false,
            Default = "3",
        })
        Dropddown:SetValue("3")
        Dropddown:OnChanged(function(Value) speeddo = tonumber(Value) end)
        local migaa = Tabs.Mina:AddToggle("op", {
            Title = "Visualizer",
            Description = "Auto Parry Range Visualizer",
            Default = false,
        })
        migaa:OnChanged(function(v) visualize_Enabled = v end)
        Tabs.Mina:AddButton({
            Title = "Optimize",
            Description = "Smoothen Ur Game Performance",
            Callback = function() optimizer() end
        })
        Tabs.Credits:AddButton({
            Title = "Josh",
            Description = "Main Owner",
            Callback = function() print("Josh") end
        })
        Tabs.Credits:AddButton({
            Title = "CBB",
            Description = "Assistant Developer",
            Callback = function() print("CBB") end
        })
        Tabs.Credits:AddButton({
            Title = "I Love Femboys",
            Description = "Source, main dev",
            Callback = function() print("I Love Yo Mama") end
        })
    end

    LocalPlayer.Idled:Connect(function()
        VirtualUser:CaptureController()
        VirtualUser:ClickButton2(Vector2.new(0, 0))
    end)

    local custom_win_audio = Instance.new('Sound', sounds_folder or ReplicatedStorage) -- Fallback ke ReplicatedStorage jika sounds_folder nil

    local ScreenGui2 = Instance.new("ScreenGui")
    ScreenGui2.Parent = game.CoreGui
    ScreenGui2.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    local ImageButton = Instance.new("ImageButton")
    ImageButton.Parent = ScreenGui2
    ImageButton.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
    ImageButton.BorderSizePixel = 0
    ImageButton.Position = UDim2.new(0.120833337, 0, 0.0952890813, 0)
    ImageButton.Size = UDim2.new(0, 50, 0, 50)
    ImageButton.Image = "rbxassetid://117922950166645"
    ImageButton.Draggable = true
    local UICorner = Instance.new("UICorner")
    UICorner.Parent = ImageButton
    ImageButton.MouseButton1Click:Connect(function()
        game:GetService("VirtualInputManager"):SendKeyEvent(true, Enum.KeyCode.LeftControl, false, game)
    end)

    FlurioreLib:MakeNotify({
        ["Title"] = "VicoX⛅",
        ["Description"] = "",
        ["Color"] = Color3.fromRGB(0, 0, 128),
        ["Content"] = "Loaded Successfully!",
        ["Time"] = 1,
        ["Delay"] = 5
    })

    local getedping = 0
    local pingSpikeNotified = false
    local autoSpamNotified = false
    local notificationCooldown = 7.5
    local lastNotificationTime = 0
    local lastAutoSpamNotificationTime = 0

    task.delay(1, function()
        local player_ping = Player.Entity.properties.ping
        if player_ping > 100 and player_ping < 200 then
            FlurioreLib:MakeNotify({
                ["Title"] = "[Warning]:",
                ["Description"] = "Connection Problem",
                ["Color"] = Color3.fromRGB(255, 255, 0),
                ["Content"] = "Low connection speed, delays may occur",
                ["Time"] = 1,
                ["Delay"] = 5
            })
        elseif player_ping >= 200 then
            FlurioreLib:MakeNotify({
                ["Title"] = "[Critical]:",
                ["Description"] = "Connection Problem",
                ["Color"] = Color3.fromRGB(255, 0, 0),
                ["Content"] = "Critically slow connection speed, delays ensured",
                ["Time"] = 1,
                ["Delay"] = 5
            })
        end
    end)

    RunService.PreSimulation:Connect(function()
        if AutoParry.ball.properties.auto_spam and not autoSpamNotified then
            local currentAutoSpamTime = tick()
            if currentAutoSpamTime - lastAutoSpamNotificationTime >= notificationCooldown then
                FlurioreLib:MakeNotify({
                    ["Title"] pove = "[Information]:",
                    ["Description"] = "Auto Parry Behavior",
                    ["Color"] = Color3.fromRGB(255, 0, 0),
                    ["Content"] = "Auto Spam Activated",
                    ["Time"] = 1,
                    ["Delay"] = 5
                })
                autoSpamNotified = true
                lastAutoSpamNotificationTime = currentAutoSpamTime
            end
        else
            autoSpamNotified = false
        end
    end)

    local validKeys = {"VicoX"}
    local keySubmitted = false
    local screenGui = Instance.new("ScreenGui")
    screenGui.Parent = game.CoreGui

    local blur = Instance.new("Frame")
    blur.Size = UDim2.new(0, 320, 0, 170)
    blur.Position = UDim2.new(0.5, -160, 0.5, -85)
    blur.BackgroundTransparency = 0.2
    blur.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    blur.Parent = screenGui
    local backgroundGradient = Instance.new("UIGradient")
    backgroundGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 0))
    }
    backgroundGradient.Parent = blur
    local blurCorner = Instance.new("UICorner")
    blurCorner.CornerRadius = UDim.new(0.15, 0)
    blurCorner.Parent = blur

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 300, 0, 150)
    frame.Position = UDim2.new(0.5, -150, 0.5, -75)
    frame.BackgroundTransparency = 0.1
    frame.Parent = blur
    local frameGradient = Instance.new("UIGradient")
    frameGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 0))
    }
    frameGradient.Parent = frame
    local frameCorner = Instance.new("UICorner")
    frameCorner.CornerRadius = UDim.new(0.15, 0)
    frameCorner.Parent = frame

    local textbox = Instance.new("TextBox")
    textbox.Size = UDim2.new(0.9, 0, 0.3, 0)
    textbox.Position = UDim2.new(0.05, 0, 0.2, 0)
    textbox.PlaceholderText = "Enter Key"
    textbox.TextScaled = true
    textbox.TextColor3 = Color3.new(1, 1, 1)
    textbox.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
    textbox.Parent = frame
    local textboxCorner = Instance.new("UICorner")
    textboxCorner.CornerRadius = UDim.new(0.1, 0)
    textboxCorner.Parent = textbox

    local submitButton = Instance.new("TextButton")
    submitButton.Size = UDim2.new(0.4, 0, 0.2, 0)
    submitButton.Position = UDim2.new(0.05, 0, 0.65, 0)
    submitButton.Text = "Submit Key"
    submitButton.TextScaled = true
    submitButton.TextColor3 = Color3.new(1, 1, 1)
    local submitGradient = Instance.new("UIGradient")
    submitGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 0))
    }
    submitGradient.Parent = submitButton
    submitButton.Parent = frame
    local submitCorner = Instance.new("UICorner")
    submitCorner.CornerRadius = UDim.new(0.2, 0)
    submitCorner.Parent = submitButton

    local getKeyButton = Instance.new("TextButton")
    getKeyButton.Size = UDim2.new(0.4, 0, 0.2, 0)
    getKeyButton.Position = UDim2.new(0.55, 0, 0.65, 0)
    getKeyButton.Text = "Get Key"
    getKeyButton.TextScaled = true
    getKeyButton.TextColor3 = Color3.new(1, 1, 1)
    local getKeyGradient = Instance.new("UIGradient")
    getKeyGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 255, 255)),
        ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 0))
    }
    getKeyGradient.Parent = getKeyButton
    getKeyButton.Parent = frame
    local getKeyCorner = Instance.new("UICorner")
    getKeyCorner.CornerRadius = UDim.new(0.2, 0)
    getKeyCorner.Parent = getKeyButton

    local function hoverEffect(button)
        button.MouseEnter:Connect(function() button:TweenSize(UDim2.new(0.42, 0, 0.22, 0), "Out", "Quad", 0.2, true) end)
        button.MouseLeave:Connect(function() button:TweenSize(UDim2.new(0.4, 0, 0.2, 0), "Out", "Quad", 0.2, true) end)
    end
    hoverEffect(submitButton)
    hoverEffect(getKeyButton)

    textbox:TweenPosition(UDim2.new(0.05, 0, 0.2, 0), "Out", "Quad", 0.5, true)
    submitButton:TweenPosition(UDim2.new(0.05, 0, 0.65, 0), "Out", "Quad", 0.5, true)
    getKeyButton:TweenPosition(UDim2.new(0.55, 0, 0.65, 0), "Out", "Quad", 0.5, true)

    local function checkKey(key)
        for _, validKey in ipairs(validKeys) do
            if key == validKey then return true end
        end
        return false
    end

    local function displayNotification(title, text, duration)
        game.StarterGui:SetCore("SendNotification", {Title = title, Text = text, Duration = duration})
    end

    local function saveKey(key)
        local success, err = pcall(function() writefile("SavedWaverHub.txt", key) end)
        if not success then warn("Failed to save key: " .. err) end
    end

    local function loadSavedKey()
        local success, result = pcall(function() if isfile("SavedWaverHub.txt") then return readfile("SavedWaverHub.txt") end end)
        return success and result or nil
    end

    local savedKey = loadSavedKey()
    if savedKey and checkKey(savedKey) then
        keySubmitted = true
        displayNotification("Key System", "Saved key is valid! Access Granted!", 3)
        screenGui:Destroy()
        ScriptLoader()
    else
        displayNotification("Key System", "No valid saved key found.", 3)
    end

    submitButton.MouseButton1Click:Connect(function()
        local inputKey = textbox.Text
        if checkKey(inputKey) then
            saveKey(inputKey)
            displayNotification("Key System", "Correct Key Entered! UI is closing...", 3)
            task.wait(2)
            keySubmitted = true
            screenGui:Destroy()
            displayNotification("Key System", "Access Granted!", 3)
            ScriptLoader()
        else
            displayNotification("Key System", "Invalid key entered!", 3)
            textbox.Text = ""
        end
    end)

    getKeyButton.MouseButton1Click:Connect(function()
        setclipboard("https://discord.com/invite/PvZX8BJKbS")
        displayNotification("Key System", "Discord link has been successfully copied to your clipboard!", 3)
    end)
end

-- Mulai skrip
if not game.CoreGui:FindFirstChild("KeySystemUI") then ScriptLoader() end

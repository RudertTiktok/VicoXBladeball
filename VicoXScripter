print("if rudert < dev then start()")
print("error: wrong script broski... no im jk")

-- Services
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local Stats = game:GetService("Stats")
local VirtualInputManager = game:GetService("VirtualInputManager")
local Debris = game:GetService("Debris")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local Lighting = game:GetService("Lighting")
local TeleportService = game:GetService("TeleportService")

-- Wait for game to load
if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- Initialize NothingLibrary
local NothingLibrary = loadstring(game:HttpGetAsync('https://raw.githubusercontent.com/3345-c-a-t-s-u-s/NOTHING/main/source.lua'))()
local notify = NothingLibrary.Notification()

-- Loading Screen
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "LoadingScreen"
screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
frame.BackgroundTransparency = 0.6
frame.Parent = screenGui

local uiGradient = Instance.new("UIGradient")
uiGradient.Parent = frame
uiGradient.Color = ColorSequence.new(Color3.fromRGB(0, 0, 0), Color3.fromRGB(50, 50, 50))
uiGradient.Rotation = 45

local textLabel = Instance.new("TextLabel")
textLabel.Text = "Credit: Rudert, Flezzpe, and VicoX"
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.TextSize = 50
textLabel.TextStrokeTransparency = 0.6
textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
textLabel.TextWrapped = true
textLabel.Size = UDim2.new(0, 550, 0, 200)
textLabel.Position = UDim2.new(0.5, -250, 0.5, -75)
textLabel.TextXAlignment = Enum.TextXAlignment.Center
textLabel.TextYAlignment = Enum.TextYAlignment.Center
textLabel.Parent = frame

local border = Instance.new("UICorner")
border.CornerRadius = UDim.new(0, 10)
border.Parent = textLabel

local shadow = Instance.new("Frame")
shadow.Size = UDim2.new(1, 6, 1, 6)
shadow.Position = UDim2.new(0, 3, 0, 3)
shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
shadow.BackgroundTransparency = 0.5
shadow.ZIndex = textLabel.ZIndex - 1
shadow.Parent = textLabel

local fadeInTweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
local fadeInTween = TweenService:Create(textLabel, fadeInTweenInfo, {TextTransparency = 0, Position = UDim2.new(0.5, -250, 0.5, -75)})

local moveUpTweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
local moveUpTween = TweenService:Create(textLabel, moveUpTweenInfo, {Position = UDim2.new(0.5, -250, 0.5, -150)})

local fadeOutTweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.In)
local fadeOutTween = TweenService:Create(textLabel, fadeOutTweenInfo, {TextTransparency = 1})

fadeInTween:Play()
fadeInTween.Completed:Connect(function()
    wait(1)
    moveUpTween:Play()
    moveUpTween.Completed:Connect(function()
        fadeOutTween:Play()
        fadeOutTween.Completed:Connect(function()
            screenGui:Destroy()
        end)
    end)
end)

-- Local variables
local LocalPlayer = Players.LocalPlayer
local RunTime = Workspace:FindFirstChild("Runtime") or Workspace
local Alive = Workspace:FindFirstChild("Alive") or Workspace
local Dead = Workspace:FindFirstChild("Dead") or Workspace
local Camera = Workspace.CurrentCamera
local Cooldown = tick()
local SoundCooldown = tick()
local is_respawned = false
local lastAntiIdleTime = tick()
local parryCount = 0
local closest_Entity = nil
local old_from_target = nil
local Settings = {
    AutoParryEnabled = false,
    AutoSpamEnabled = false,
    CursorTargeting = false,
    VisualizerEnabled = false,
    AIEnabled = false,
    HitEffectEnabled = false,
    HitSoundEnabled = false,
    SelfEffectEnabled = false,
    TrailEnabled = false,
    KillEffectEnabled = false,
    ShadersEnabled = false,
    NightModeEnabled = false,
    SpectateEnabled = false,
    AntiIdleEnabled = false,
    AutoRejoinEnabled = false,
    AntiLagMode = "Disable",
    ParryDistanceThreshold = 0.65,
    CurveMethod = "Accelerated",
    BloomIntensity = 2.1,
    HitEffectParticles = 3,
    HitSound = "DC-15X"
}

-- Initialize Parry_Key and Remotes
local Parry_Key = nil
local Remotes = {}
local foundFake = false

task.spawn(function()
    for _, Value in pairs(getgc()) do
        if type(Value) == 'function' and islclosure(Value) then
            local Protos = debug.getprotos(Value) or {}
            local Upvalues = debug.getupvalues(Value) or {}
            local Constants = debug.getconstants(Value) or {}
            if #Protos == 4 and #Upvalues == 24 and #Constants >= 102 then
                local c62 = Constants[62]
                local c64 = Constants[64]
                local c65 = Constants[65]
                if c62 and c64 and c65 then
                    Remotes[debug.getupvalue(Value, 16)] = c62
                    Parry_Key = debug.getupvalue(Value, 17)
                    Remotes[debug.getupvalue(Value, 18)] = c64
                    Remotes[debug.getupvalue(Value, 19)] = c65
                    print("Found target function. Parry_Key:", Parry_Key, "Remotes:", Remotes)
                    break
                else
                    warn("Constants missing at required indices:", c62, c64, c65)
                end
            end
        end
    end
    if not Parry_Key or not next(Remotes) then
        warn("Failed to initialize Parry_Key or Remotes")
    else
        for _, Args in pairs(Remotes) do
            if Args == "PARRY_HASH_FAKE_1" or Args == "_G" then
                foundFake = true
                print("Found fake hash:", Args)
                break
            end
        end
    end
end)

local Key = Parry_key;

-- Data Folder
local nurysium_Data = Instance.new('Folder', game:GetService('CoreGui'))
nurysium_Data.Name = 'nurysium_temp'

local hit_Sound = Instance.new('Sound', nurysium_Data)
hit_Sound.SoundId = 'rbxassetid://936447863' -- Default to DC-15X
hit_Sound.Volume = 3

-- Connections management
local ConnectionsManager = {}
function ConnectionsManager.disconnect(key)
    local connection = ConnectionsManager[key]
    if connection then
        connection:Disconnect()
        ConnectionsManager[key] = nil
    end
end

-- Visualizer setup (Part-based)
local Visualize = Instance.new("Part", Workspace)
Visualize.Color = Color3.new(0, 0, 0)
Visualize.Material = Enum.Material.ForceField
Visualize.Transparency = 1
Visualize.Anchored = true
Visualize.CanCollide = false
Visualize.CastShadow = false
Visualize.Shape = Enum.PartType.Ball
Visualize.Size = Vector3.new(30, 30, 30)

local Visualize1 = Instance.new("Part", Workspace)
Visualize1.Color = Color3.new(1, 0, 0)
Visualize1.Material = Enum.Material.ForceField
Visualize1.Transparency = 1
Visualize1.Anchored = true
Visualize1.CanCollide = false
Visualize1.CastShadow = false
Visualize1.Shape = Enum.PartType.Ball
Visualize1.Size = Vector3.new(0, 0, 0)

local Highlight = Instance.new("Highlight")
Highlight.Parent = Visualize
Highlight.Enabled = true
Highlight.FillTransparency = 0
Highlight.OutlineColor = Color3.new(1, 1, 1)

local Highlight1 = Instance.new("Highlight")
Highlight1.Parent = Visualize1
Highlight1.Enabled = true
Highlight1.FillTransparency = 0
Highlight1.OutlineColor = Color3.new(1, 1, 1)

-- AutoParry and Player structures
local AutoParry = {
    ball = nil,
    target = nil,
    entity_properties = nil
}

local Player = {
    Entity = nil,
    properties = {
        grab_animation = nil
    }
}

Player.Entity = {
    properties = {
        sword = '',
        server_position = Vector3.zero,
        velocity = Vector3.zero,
        position = Vector3.zero,
        is_moving = false,
        speed = 0,
        ping = 0
    }
}

AutoParry.ball = {
    training_ball_entity = nil,
    client_ball_entity = nil,
    ball_entity = nil,
    properties = {
        aero_dynamic_time = tick(),
        hell_hook_completed = true,
        last_position = Vector3.zero,
        rotation = Vector3.zero,
        position = Vector3.zero,
        last_warping = tick(),
        is_curved = false,
        last_tick = tick(),
        auto_spam = false,
        cooldown = false,
        respawn_time = 0,
        parry_range = 3,
        spam_range = 2,
        maximum_speed = 0,
        old_speed = 0,
        parries = 0,
        direction = 0,
        distance = 0,
        velocity = 0,
        last_hit = 0,
        lerp_radians = 0,
        radians = 0,
        speed = 0,
        dot = 0
    }
}

AutoParry.target = {
    current = nil,
    from = nil,
    aim = nil,
}

AutoParry.entity_properties = {
    server_position = Vector3.zero,
    velocity = Vector3.zero,
    is_moving = false,
    direction = 0,
    distance = 0,
    speed = 0,
    dot = 0
}

-- Utility Functions
local function linear_predict(a, b, time_volume)
    return a + (b - a) * time_volume
end

local function get_pointer()
    local mousePos = UserInputService:GetMouseLocation()
    local ray = Camera and Camera:ScreenPointToRay(mousePos.X, mousePos.Y) or { Direction = Vector3.new(0, 0, -1) }
    return CFrame.new(Vector3.zero, ray.Direction)
end

local function get_closest_entity()
    local closest = nil
    local max_distance = math.huge
    for _, entity in Alive:GetChildren() do
        if entity.Name ~= LocalPlayer.Name and entity:FindFirstChild("HumanoidRootPart") then
            local distance = (LocalPlayer.Character and LocalPlayer.Character.PrimaryPart and LocalPlayer.Character.PrimaryPart.Position - entity.HumanoidRootPart.Position).Magnitude
            if distance < max_distance then
                closest_Entity = entity
                max_distance = distance
            end
        end
    end
    return closest_Entity
end

-- Player Functions
function Player.get_aim_entity()
    local closest_entity = nil
    local minimal_dot_product = -math.huge
    local camera_direction = Camera and Camera.CFrame.LookVector or Vector3.new(0, 0, -1)
    for _, player in Alive:GetChildren() do
        if not player or player.Name == LocalPlayer.Name or not player:FindFirstChild("HumanoidRootPart") then
            continue
        end
        local entity_direction = (player.HumanoidRootPart.Position - (Camera and Camera.CFrame.Position or Vector3.zero)).Unit
        local dot_product = camera_direction:Dot(entity_direction)
        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_entity = player
        end
    end
    return closest_entity
end

function Player.get_closest_player_to_cursor()
    local closest_player = nil
    local minimal_dot_product = -math.huge
    local pointer = get_pointer()
    for _, player in Alive:GetChildren() do
        if player == LocalPlayer.Character or player.Parent ~= Alive or not player:FindFirstChild("PrimaryPart") then
            continue
        end
        local player_direction = (player.PrimaryPart.Position - (Camera and Camera.CFrame.Position or Vector3.zero)).Unit
        local dot_product = pointer.LookVector:Dot(player_direction)
        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_player = player
        end
    end
    return closest_player
end

-- AutoParry Functions
AutoParry.get_ball = function()
    for _, instance in pairs(Workspace.Balls:GetChildren()) do
        if instance:GetAttribute("realBall") then
            instance.CanCollide = false
            return instance
        end
    end
end

function AutoParry.get_client_ball()
    return AutoParry.get_ball()
end

function AutoParry.reset()
    local ball_properties = AutoParry.ball.properties
    ball_properties.is_curved = false
    ball_properties.auto_spam = false
    ball_properties.cooldown = false
    ball_properties.maximum_speed = 0
    ball_properties.parries = 0
    ball_properties.last_hit = 0
    AutoParry.entity_properties.server_position = Vector3.zero
    AutoParry.target.current = nil
    AutoParry.target.from = nil
    AutoParry.target.aim = nil
    Visualize.Transparency = 1
    Visualize1.Transparency = 1
end

function AutoParry.perform_grab_animation()
    local animation = ReplicatedStorage.Shared.SwordAPI and ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local currently_equipped = Player.Entity.properties.sword
    
    if not currently_equipped or currently_equipped == 'Titan Blade' or not animation then
        return
    end

    local sword_data = ReplicatedStorage.Shared.ReplicatedInstances and ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(currently_equipped)

    if not sword_data or not sword_data['AnimationType'] then
        return
    end

    local character = LocalPlayer.Character

    if not character or not character:FindFirstChild('Humanoid') then
        return
    end

    for _, object in ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren() do
        if object.Name ~= sword_data['AnimationType'] then
            continue
        end
        
        if not (object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab')) then
            continue
        end

        local sword_animation_type = object:FindFirstChild('Grab') and 'Grab' or 'GrabParry'
        animation = object[sword_animation_type]
    end

    Player.Entity.properties.grab_animation = character.Humanoid:LoadAnimation(animation)
    Player.Entity.properties.grab_animation:Play()
end

function AutoParry.parry_data()
    local Camera = workspace.CurrentCamera
    if not Camera then
        warn("Camera not found")
        return {0, CFrame.new(), {}, {0, 0}}
    end

    local ViewportSize = Camera.ViewportSize
    local MouseLocation = UserInputService:GetMouseLocation()
    local Used = {MouseLocation.X, MouseLocation.Y}

    if Settings.CursorTargeting then
        local closestPlayer = Player.get_closest_player_to_cursor()
        if closestPlayer and closestPlayer.PrimaryPart then
            Used = Camera:WorldToScreenPoint(closestPlayer.PrimaryPart.Position)
        end
    else
        local closestPlayer = get_closest_entity()
        if closestPlayer and closestPlayer.PrimaryPart then
            Used = Camera:WorldToScreenPoint(closestPlayer.PrimaryPart.Position)
        end
    end

    local Alive = workspace:FindFirstChild("Alive") or workspace
    local Events = {}
    for _, v in ipairs(Alive:GetChildren()) do
        if v:IsA("Model") and v.PrimaryPart then
            Events[tostring(v)] = Camera:WorldToScreenPoint(v.PrimaryPart.Position)
        end
    end

    local pos = Camera.CFrame.Position
    local look = Camera.CFrame.LookVector
    local up = Camera.CFrame.UpVector
    local right = Camera.CFrame.RightVector

    local directions = {
        Up = pos + up * 1000,
        Right = pos + right * 1000,
        Left = pos - right * 1000,
        Accelerated = pos + look * 1000,
        Backwards = pos - look * 1000,
        Random = Vector3.new(math.random(-3000, 3000), math.random(-3000, 3000), math.random(-3000, 3000))
    }

    local lookTarget = directions[Settings.CurveMethod] or directions.Accelerated
    local DirectionCF = CFrame.new(pos, lookTarget)

    return {0, DirectionCF, Events, Used}
end

function AutoParry.perform_parry()
    local ball_properties = AutoParry.ball.properties
    
    if ball_properties.cooldown and not ball_properties.auto_spam then
        return
    end

    if tick() - Cooldown < 0.1 or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or not Camera then
        return
    end

    ball_properties.parries += 1
    ball_properties.last_hit = tick()
    parryCount += 1
    notify.new({
        Title = "Parry Success",
        Description = "Parry Count: " .. parryCount,
        Duration = 0.01,
        Icon = "rbxassetid://8997385628"
    })

    if ball_properties.parries > 7 then
        return
    end

    local is_mobile = UserInputService.TouchEnabled
    local aim_target = Settings.CursorTargeting and not is_mobile and Player.get_closest_player_to_cursor() or Player.get_aim_entity()
    AutoParry.target.aim = aim_target or AutoParry.target.aim
    if AutoParry.target.aim and AutoParry.target.aim:FindFirstChild("PrimaryPart") then
        local target_position = AutoParry.target.aim.PrimaryPart.Position
        if AutoParry.ball.ball_entity then
            local ball_vel = ball_properties.velocity
            local time_to_reach = ball_properties.distance / ball_properties.speed
            target_position = linear_predict(ball_properties.position, ball_properties.position + ball_vel * time_to_reach, time_to_reach)
        end
        AutoParry.entity_properties.server_position = target_position
    end

    local Parry_Data = AutoParry.parry_data()
    for Remote, Args in pairs(Remotes) do
        local Hash
        if foundFake then
            Hash = nil
        else
            Hash = Args
        end
        Remote:FireServer(Hash, Key, Parry_Data[1], Parry_Data[2], Parry_Data[3], Parry_Data[4])
    end

    if not ball_properties.auto_spam then
        AutoParry.perform_grab_animation()
        ball_properties.cooldown = true
    end

    if Settings.HitEffectEnabled then
        AutoParry.play_hit_effect()
    end
    if Settings.HitSoundEnabled and tick() - SoundCooldown > 0.1 then
        hit_Sound:Play()
        SoundCooldown = tick()
    end

    task.delay(ball_properties.auto_spam and 0.15 or 0.25, function()
        if ball_properties.parries > 0 then
            ball_properties.parries -= 1
        end
    end)

    Cooldown = tick()
end

function AutoParry.play_hit_effect()
    if not Settings.HitEffectEnabled then return end
    local ball = AutoParry.get_ball()
    if not ball then
        warn("No ball found for hit effect")
        return
    end
    local hit_effect = game:GetObjects("rbxassetid://17407244385")[1]
    hit_effect.Parent = ball
    hit_effect:Emit(Settings.HitEffectParticles)
    task.delay(5, function()
        hit_effect:Destroy()
    end)
end

function AutoParry.play_kill_effect(part)
    if not Settings.KillEffectEnabled then return end
    local bell = game:GetObjects("rbxassetid://17519762269")[1]
    bell.Name = 'Yeat_BELL'
    bell.Parent = Workspace
    bell.Position = part.Position - Vector3.new(0, 20, 0)
    bell:WaitForChild('Sound'):Play()
    TweenService:Create(bell, TweenInfo.new(0.85, Enum.EasingStyle.Exponential, Enum.EasingDirection.InOut), {
        Position = part.Position + Vector3.new(0, 10, 0)
    }):Play()
    task.delay(5, function()
        TweenService:Create(bell, TweenInfo.new(1.75, Enum.EasingStyle.Exponential, Enum.EasingDirection.InOut), {
            Position = part.Position + Vector3.new(0, 100, 0)
        }):Play()
    end)
    task.delay(6, function()
        bell:Destroy()
    end)
end

function AutoParry.is_curved()
    local target = AutoParry.target.current
    if not target then
        return false
    end

    local ball_properties = AutoParry.ball.properties
    local current_target = target.Name

    if target.PrimaryPart:FindFirstChild('MaxShield') and current_target ~= LocalPlayer.Name and ball_properties.distance < 50 then
        return false
    end

    if AutoParry.ball.ball_entity then
        if AutoParry.ball.ball_entity:FindFirstChild('TimeHole1') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
            ball_properties.auto_spam = false
            return false
        end

        if AutoParry.ball.ball_entity:FindFirstChild('WEMAZOOKIEGO') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
            return false
        end

        if AutoParry.ball.ball_entity:FindFirstChild('At2') and ball_properties.speed <= 0 then
            return true
        end

        if AutoParry.ball.ball_entity:FindFirstChild('AeroDynamicSlashVFX') then
            Debris:AddItem(AutoParry.ball.ball_entity.AeroDynamicSlashVFX, 0)
            ball_properties.auto_spam = false
            ball_properties.aero_dynamic_time = tick()
        end
    end

    if RunTime:FindFirstChild('Tornado') then
        if ball_properties.distance > 5 and (tick() - ball_properties.aero_dynamic_time) < (RunTime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then
            return true
        end
    end

    if not ball_properties.hell_hook_completed and target.Name == LocalPlayer.Name and ball_properties.distance > 5 - math.random() then
        return true
    end
    
    local ball_direction = ball_properties.velocity.Unit
    local ball_speed = ball_properties.speed
    
    local speed_threshold = math.min(ball_speed / 100, 40)
    local angle_threshold = 40 * math.max(ball_properties.dot, 0)

    local player_ping = Player.Entity.properties.ping

    local accurate_direction = ball_properties.velocity.Unit * ball_direction
    local direction_difference = (accurate_direction - ball_properties.velocity).Unit
    local accurate_dot = ball_properties.direction:Dot(direction_difference)
    local dot_difference = ball_properties.dot - accurate_dot
    local dot_threshold = 0.5 - player_ping / 1000

    local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)
    local enough_speed = ball_properties.maximum_speed > 100

    local ball_distance_threshold = 15 - math.min(ball_properties.distance / 1000, 15) + angle_threshold + speed_threshold
    
    if enough_speed and reach_time > player_ping / 10 then
        ball_distance_threshold = math.max(ball_distance_threshold - 15, 15)
    end
    
    if ball_properties.distance < ball_distance_threshold then
        return false
    end

    if dot_difference < dot_threshold or ball_properties.dot < dot_threshold then
        return true
    end

    if ball_properties.lerp_radians < 0.018 then
        ball_properties.last_curve_position = ball_properties.position
        ball_properties.last_warping = tick() 
    end

    if (tick() - ball_properties.last_warping) < (reach_time / 1.5) then
        return true
    end

    return false
end

function AutoParry.is_spam(params)
    local target = AutoParry.target.current
    if not target then
        return false
    end

    local ball_properties = AutoParry.ball.properties
    local entity_properties = AutoParry.entity_properties
    local speed = params.speed
    local spam_accuracy = params.spam_accuracy
    local parries = params.parries
    local ball_distance = params.ball_distance
    local maximum_speed = params.maximum_speed
    local old_speed = params.old_speed
    local entity_distance = params.entity_distance
    local last_hit = params.last_hit
    local last_position_distance = params.last_position_distance
    local range = params.range

    if AutoParry.target.from ~= LocalPlayer.Character then
        old_from_target = AutoParry.target.from
    end

    if parries < 3 and AutoParry.target.from == old_from_target then
        return false
    end

    local player_ping = Player.Entity.properties.ping
    local distance_threshold = 18 + (player_ping / 80)
    local reach_time = ball_distance / maximum_speed - (player_ping / 1000)

    if (tick() - last_hit) > 0.8 and entity_distance > distance_threshold and parries < 3 then
        ball_properties.parries = 1
        return false
    end

    if ball_properties.lerp_radians > 0.028 then
        if parries > 3 then
            ball_properties.parries = 1
        end
        return false
    end

    if (tick() - ball_properties.last_warping) < (reach_time / 1.3) and entity_distance > distance_threshold and parries < 4 then
        if parries > 3 then
            ball_properties.parries = 1
        end
        return false
    end

    if math.abs(speed - old_speed) < 5.2 and entity_distance > distance_threshold and speed < 60 and parries < 3 then
        if parries > 3 then
            ball_properties.parries = 0
        end
        return false
    end

    if speed < 10 then
        ball_properties.parries = 1
        return false
    end

    if maximum_speed < speed and entity_distance > distance_threshold then
        ball_properties.parries = 1
        return false
    end

    if entity_distance > range and entity_distance > distance_threshold then
        if parries > 2 then
            ball_properties.parries = 1
        end
        return false
    end

    if ball_distance > range and entity_distance > distance_threshold then
        if parries > 2 then
            ball_properties.parries = 2
        end
        return false
    end

    if last_position_distance > spam_accuracy and entity_distance > distance_threshold then
        if parries > 4 then
            ball_properties.parries = 2
        end
        return false
    end

    if ball_distance > spam_accuracy and ball_distance > distance_threshold then
        if parries > 3 then
            ball_properties.parries = 2
        end
        return false
    end

    if entity_distance > spam_accuracy and entity_distance > (distance_threshold - math.pi) then
        if parries > 3 then
            ball_properties.parries = 2
        end
        return false
    end

    return true
end

function AutoParry.run_ai()
    if not Settings.AIEnabled or not LocalPlayer.Character or not Alive:FindFirstChild(LocalPlayer.Character.Name) then
        return
    end
    local ball = AutoParry.get_ball()
    if not ball or not closest_Entity then
        return
    end
    if not closest_Entity:FindFirstChild('HumanoidRootPart') then
        if LocalPlayer.Character.Humanoid then
            LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(math.sin(tick()) * math.random(35, 50), 0, math.cos(tick()) * math.random(35, 50)))
        end
        return
    end
    local ball_Position = ball.Position
    local ball_Speed = ball.AssemblyLinearVelocity.Magnitude
    local ball_Distance = LocalPlayer:DistanceFromCharacter(ball_Position)
    local player_Position = LocalPlayer.Character.PrimaryPart.Position
    local target_Position = closest_Entity.HumanoidRootPart.Position
    local target_Distance = LocalPlayer:DistanceFromCharacter(target_Position)
    local target_LookVector = closest_Entity.HumanoidRootPart.CFrame.LookVector
    local resolved_Position = Vector3.zero
    local target_Humanoid = closest_Entity:FindFirstChildOfClass("Humanoid")
    if target_Humanoid and target_Humanoid:GetState() == Enum.HumanoidStateType.Jumping and LocalPlayer.Character.Humanoid.FloorMaterial ~= Enum.Material.Air then
        LocalPlayer.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
    if (ball_Position - player_Position):Dot(LocalPlayer.Character.PrimaryPart.CFrame.LookVector) < -0.2 and tick() % 4 <= 2 then
        return
    end
    if tick() % 4 <= 2 then
        if target_Distance > 10 then
            resolved_Position = target_Position + (player_Position - target_Position).Unit * 8
        else
            resolved_Position = target_Position + (player_Position - target_Position).Unit * 25
        end
    else
        resolved_Position = target_Position - target_LookVector * (math.random(8.5, 13.5) + (ball_Distance / math.random(8, 20)))
    end
    if (player_Position - target_Position).Magnitude < 8 then
        resolved_Position = target_Position + (player_Position - target_Position).Unit * 35
    end
    if ball_Distance < 8 then
        resolved_Position = player_Position + (player_Position - ball_Position).Unit * 10
    end
    if AutoParry.ball.properties.auto_spam then
        resolved_Position = player_Position + (ball_Position - player_Position).Unit * 10
    end
    if LocalPlayer.Character.Humanoid then
        LocalPlayer.Character.Humanoid:MoveTo(resolved_Position + Vector3.new(math.sin(tick()) * 10, 0, math.cos(tick()) * 10))
    end
end

-- Anti-Idle
task.defer(function()
    RunService.Heartbeat:Connect(function()
        if not Settings.AntiIdleEnabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("Humanoid") then
            return
        end
        if tick() - lastAntiIdleTime >= 30 and Player.Entity.properties.speed < 1 then
            LocalPlayer.Character.Humanoid:MoveTo(LocalPlayer.Character.HumanoidRootPart.Position + Vector3.new(math.random(-5, 5), 0, math.random(-5, 5)))
            lastAntiIdleTime = tick()
        end
    end)
end)

-- Self Effect
task.defer(function()
    RunService.Heartbeat:Connect(function()
        if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
            return
        end
        if Settings.SelfEffectEnabled then
            local effect = game:GetObjects("rbxassetid://17519530107")[1]
            effect.Name = 'nurysium_efx'
            if not LocalPlayer.Character.PrimaryPart:FindFirstChild('nurysium_efx') then
                effect.Parent = LocalPlayer.Character.PrimaryPart
            end
        else
            if LocalPlayer.Character.PrimaryPart:FindFirstChild('nurysium_efx') then
                LocalPlayer.Character.PrimaryPart['nurysium_efx']:Destroy()
            end
        end
    end)
end)

-- Trail
task.defer(function()
    RunService.Heartbeat:Connect(function()
        if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
            return
        end
        if Settings.TrailEnabled then
            local trail = game:GetObjects("rbxassetid://17483658369")[1]
            trail.Name = 'nurysium_fx'
            if not LocalPlayer.Character.PrimaryPart:FindFirstChild('nurysium_fx') then
                local Attachment0 = Instance.new("Attachment", LocalPlayer.Character.PrimaryPart)
                local Attachment1 = Instance.new("Attachment", LocalPlayer.Character.PrimaryPart)
                Attachment0.Position = Vector3.new(0, -2.411, 0)
                Attachment1.Position = Vector3.new(0, 2.504, 0)
                trail.Parent = LocalPlayer.Character.PrimaryPart
                trail.Attachment0 = Attachment0
                trail.Attachment1 = Attachment1
            end
        else
            if LocalPlayer.Character.PrimaryPart:FindFirstChild('nurysium_fx') then
                LocalPlayer.Character.PrimaryPart['nurysium_fx']:Destroy()
            end
        end
    end)
end)

-- Shaders
task.defer(function()
    while task.wait(1) do
        if Settings.ShadersEnabled then
            TweenService:Create(Lighting.Bloom, TweenInfo.new(4), {
                Size = 100,
                Intensity = Settings.BloomIntensity
            }):Play()
        else
            TweenService:Create(Lighting.Bloom, TweenInfo.new(3), {
                Size = 3,
                Intensity = 1
            }):Play()
        end
    end
end)

-- Night Mode
task.defer(function()
    while task.wait(1) do
        if Settings.NightModeEnabled then
            TweenService:Create(Lighting, TweenInfo.new(3), {ClockTime = 1.9}):Play()
        else
            TweenService:Create(Lighting, TweenInfo.new(3), {ClockTime = 13.5}):Play()
        end
    end
end)

-- Spectate Ball
task.defer(function()
    RunService.RenderStepped:Connect(function()
        if Settings.SpectateEnabled then
            local ball = AutoParry.get_ball()
            if not ball then return end
            Camera.CFrame = Camera.CFrame:Lerp(CFrame.new(Camera.CFrame.Position, ball.Position), 0.15)
        end
    end)
end)

-- Kill Effect
task.defer(function()
    Alive.ChildRemoved:Connect(function(child)
        if not Workspace.Dead:FindFirstChild(child.Name) and child ~= LocalPlayer.Character and #Alive:GetChildren() > 1 then
            return
        end
        if Settings.KillEffectEnabled and child:FindFirstChild("HumanoidRootPart") then
            AutoParry.play_kill_effect(child.HumanoidRootPart)
        end
    end)
end)

-- Event Handlers
ReplicatedStorage.Remotes.PlrHellHooked.OnClientEvent:Connect(function(hooker)
    AutoParry.ball.properties.hell_hook_completed = hooker and hooker.Name == LocalPlayer.Name
end)

ReplicatedStorage.Remotes.PlrHellHookCompleted.OnClientEvent:Connect(function()
    AutoParry.ball.properties.hell_hook_completed = true
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(_, root)
    task.spawn(function()
        if root.Parent and root.Parent ~= LocalPlayer.Character and root.Parent.Parent == Alive then
            AutoParry.ball.properties.cooldown = false
        end
    end)
    if AutoParry.ball.properties.auto_spam then
        AutoParry.perform_parry()
    end
end)

ReplicatedStorage.Remotes.ParrySuccess.OnClientEvent:Connect(function()
    if Settings.HitSoundEnabled and tick() - SoundCooldown > 0.1 then
        hit_Sound:Play()
        SoundCooldown = tick()
    end
    AutoParry.play_hit_effect()
end)

Workspace.Balls.ChildAdded:Connect(function()
    if is_respawned then
        return
    end
    is_respawned = true
    local ball_properties = AutoParry.ball.properties
    ball_properties.respawn_time = tick()
    AutoParry.ball.ball_entity = AutoParry.get_ball()
    AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()
    if AutoParry.ball.ball_entity then
        ConnectionsManager["on_target_change"] = AutoParry.ball.ball_entity:GetAttributeChangedSignal("target"):Connect(function()
            local target = AutoParry.ball.ball_entity:GetAttribute("target")
            if target == LocalPlayer.Name then
                ball_properties.cooldown = false
                return
            end
            ball_properties.cooldown = false
            ball_properties.old_speed = ball_properties.speed
            ball_properties.last_position = ball_properties.position
            ball_properties.parries += 1
            task.delay(0.20, function()
                if ball_properties.parries > 0 then
                    ball_properties.parries -= 1
                end
            end)
        end)
    end
end)

Workspace.Balls.ChildRemoved:Connect(function(child)
    if child ~= AutoParry.ball.ball_entity then
        return
    end
    is_respawned = false
    AutoParry.ball.ball_entity = nil
    AutoParry.ball.client_ball_entity = nil
    ConnectionsManager.disconnect("on_target_change")
    AutoParry.reset()
end)

-- Simulation Loops
RunService:BindToRenderStep("server_position_simulation", 1, function()
    local ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
    if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        return
    end
    local old_position = LocalPlayer.Character.PrimaryPart.Position
    task.delay(ping / 1000, function()
        Player.Entity.properties.server_position = old_position
    end)
end)

RunService.PreSimulation:Connect(function()
    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then
        return
    end
    local player_properties = Player.Entity.properties
    player_properties.sword = character:GetAttribute("CurrentlyEquippedSword") or ""
    player_properties.ping = Stats.Network.ServerStatsItem["Data Ping"]:GetValue()
    player_properties.velocity = character.PrimaryPart.AssemblyLinearVelocity
    player_properties.speed = player_properties.velocity.Magnitude
    player_properties.is_moving = player_properties.speed > 30
    local ball = AutoParry.ball.ball_entity
    if not ball then
        return
    end
    local ball_properties = AutoParry.ball.properties
    local zoomies = ball:FindFirstChild("zoomies")
    ball_properties.position = ball.Position
    ball_properties.velocity = zoomies and zoomies.VectorVelocity or ball.AssemblyLinearVelocity
    ball_properties.distance = (Player.Entity.properties.server_position - ball_properties.position).Magnitude
    ball_properties.speed = ball_properties.velocity.Magnitude
    ball_properties.direction = (Player.Entity.properties.server_position - ball_properties.position).Unit
    ball_properties.dot = ball_properties.direction:Dot(ball_properties.velocity.Unit)
    ball_properties.radians = math.rad(math.asin(ball_properties.dot))
    ball_properties.lerp_radians = linear_predict(ball_properties.lerp_radians, ball_properties.radians, 0.8)
    if not (ball_properties.lerp_radians < 0) and not (ball_properties.lerp_radians > 0) then
        ball_properties.lerp_radians = 0.027
    end
    ball_properties.maximum_speed = math.max(ball_properties.speed, ball_properties.maximum_speed)
    AutoParry.target.current = Alive:FindFirstChild(ball:GetAttribute("target"))
    if ball:GetAttribute("from") then
        AutoParry.target.from = Alive:FindFirstChild(ball:GetAttribute("from"))
    end
    AutoParry.target.aim = (Settings.CursorTargeting and not UserInputService.TouchEnabled and Player.get_closest_player_to_cursor()) or Player.get_aim_entity()
    ball_properties.rotation = ball_properties.position
    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name and AutoParry.target.aim and AutoParry.target.aim.PrimaryPart then
        ball_properties.rotation = AutoParry.target.aim.PrimaryPart.Position
    end
    if AutoParry.target.current and AutoParry.target.current.PrimaryPart then
        local target_server_position = AutoParry.target.current.PrimaryPart.Position
        local target_velocity = AutoParry.target.current.PrimaryPart.AssemblyLinearVelocity
        AutoParry.entity_properties.server_position = target_server_position
        AutoParry.entity_properties.velocity = target_velocity
        AutoParry.entity_properties.distance = LocalPlayer:DistanceFromCharacter(target_server_position)
        AutoParry.entity_properties.direction = (Player.Entity.properties.server_position - target_server_position).Unit
        AutoParry.entity_properties.speed = target_velocity.Magnitude
        AutoParry.entity_properties.is_moving = target_velocity.Magnitude > 0.1
        AutoParry.entity_properties.dot = AutoParry.entity_properties.is_moving and math.max(AutoParry.entity_properties.direction:Dot(target_velocity.Unit), 0) or 0
    end
    closest_Entity = get_closest_entity()
end)

RunService.PreSimulation:Connect(function()
    local ball_properties = AutoParry.ball.properties
    if not ball_properties.auto_spam or ball_properties.distance > 10 or Player.Entity.properties.ping > 500 then
        return
    end
    AutoParry.perform_parry()
end)

RunService.RenderStepped:Connect(function()
    if Settings.AIEnabled then
        AutoParry.run_ai()
    end
    if not Settings.VisualizerEnabled or not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") or not AutoParry.ball.ball_entity or not Camera then
        Visualize.Transparency = 1
        Visualize1.Transparency = 1
        return
    end
    local HRP = LocalPlayer.Character.HumanoidRootPart
    local ball_properties = AutoParry.ball.properties
    local ping = Player.Entity.properties.ping
    local transparency = math.clamp(0.3 + (ping / 1000), 0.3, 0.7)
    local speed_color = ball_properties.speed > 100 and Color3.new(1, 0, 0) or Color3.new(0, 0, 1)
    Visualize.Transparency = transparency
    Visualize.Material = Enum.Material.ForceField
    Visualize.Color = speed_color
    Visualize.Size = Vector3.new(ball_properties.parry_range, ball_properties.parry_range, ball_properties.parry_range)
    Visualize.CFrame = CFrame.new(HRP.Position)
    Visualize1.Transparency = transparency
    Visualize1.Material = Enum.Material.ForceField
    Visualize1.Color = speed_color
    Visualize1.Size = Vector3.new(ball_properties.spam_range, ball_properties.spam_range, ball_properties.spam_range)
    Visualize1.CFrame = CFrame.new(HRP.Position)
end)

ConnectionsManager["auto_parry"] = RunService.PostSimulation:Connect(function()
    if not Settings.AutoParryEnabled then
        AutoParry.reset()
        return
    end

    local Character = LocalPlayer.Character
    if not Character or Character.Parent == Dead or not Character:FindFirstChild("HumanoidRootPart") or not Character:FindFirstChild("Humanoid") or Character.Humanoid.Health <= 0 then
        AutoParry.reset()
        return
    end

    if not AutoParry.ball.ball_entity then
        return
    end

    local ball_properties = AutoParry.ball.properties
    ball_properties.is_curved = AutoParry.is_curved()
    
    local ping_threshold = math.clamp(Player.Entity.properties.ping / 10, 10, 20)
    local spam_accuracy = ball_properties.maximum_speed / 7 + ping_threshold
    local parry_accuracy = ball_properties.maximum_speed / 11.5 + ping_threshold

    ball_properties.spam_range = ping_threshold + ball_properties.speed / 2.3
    ball_properties.parry_range = ping_threshold + ball_properties.speed / math.pi

    if Player.Entity.properties.sword == 'Titan Blade' then
        ball_properties.parry_range += 11
        ball_properties.spam_range += 2
    end

    local distance_to_last_position = LocalPlayer:DistanceFromCharacter(ball_properties.last_position)

    if Settings.AutoSpamEnabled and AutoParry.target.current then
        ball_properties.auto_spam = AutoParry.is_spam({
            speed = ball_properties.speed,
            spam_accuracy = spam_accuracy,
            parries = ball_properties.parries,
            ball_speed = ball_properties.speed,
            range = ball_properties.spam_range / (3.15 - ping_threshold / 10),
            last_hit = ball_properties.last_hit,
            ball_distance = ball_properties.distance,
            maximum_speed = ball_properties.maximum_speed,
            old_speed = ball_properties.old_speed,
            entity_distance = AutoParry.entity_properties.distance,
            last_position_distance = distance_to_last_position
        })
    end

    if ball_properties.auto_spam then
        return
    end

    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name and Settings.AutoSpamEnabled then
        ball_properties.auto_spam = AutoParry.is_spam({
            speed = ball_properties.speed,
            spam_accuracy = spam_accuracy,
            parries = ball_properties.parries,
            ball_speed = ball_properties.speed,
            range = ball_properties.spam_range,
            last_hit = ball_properties.last_hit,
            ball_distance = ball_properties.distance,
            maximum_speed = ball_properties.maximum_speed,
            old_speed = ball_properties.old_speed,
            entity_distance = AutoParry.entity_properties.distance,
            last_position_distance = distance_to_last_position
        })
    end

    if ball_properties.auto_spam then
        return
    end
    
    if ball_properties.is_curved then
        return
    end

    if ball_properties.distance > ball_properties.parry_range and ball_properties.distance > parry_accuracy then
        return
    end
    
    if AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character then
        return
    end

    AutoParry.perform_parry()

    task.spawn(function()
        repeat
            RunService.PreSimulation:Wait(0)
        until 
            (tick() - ball_properties.last_hit) > 1 - (ping_threshold / 100)

        ball_properties.cooldown = false
    end)
end)

-- Sound Management
local function setHitSound(soundId)
    hit_Sound.SoundId = soundId
    Settings.HitSoundEnabled = true
end

-- Anti-Lag Management
local originalSettings = {
    GlobalShadows = Lighting.GlobalShadows,
    Brightness = Lighting.Brightness,
    LevelOfDetail = Workspace.LevelOfDetail,
    FogEnd = Lighting.FogEnd,
    QualityLevel = settings().Rendering.QualityLevel
}

local function applyAntiLag(mode)
    local lighting = game:GetService("Lighting")
    local workspace = game:GetService("Workspace")

    if mode == "Disable" then
        lighting.GlobalShadows = originalSettings.GlobalShadows
        lighting.Brightness = originalSettings.Brightness
        workspace.LevelOfDetail = originalSettings.LevelOfDetail
        lighting.FogEnd = originalSettings.FogEnd
        settings().Rendering.QualityLevel = originalSettings.QualityLevel
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Part") or v:IsA("MeshPart") then
                v.Material = Enum.Material.SmoothPlastic
                v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then
                v.Transparency = 0
            elseif v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Fire") then
                v.Enabled = true
            end
        end
    elseif mode == "Anti Lag Basic" then
        lighting.GlobalShadows = false
        lighting.Brightness = 1
        workspace.LevelOfDetail = Enum.LevelOfDetailSetting.Low
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Part") or v:IsA("MeshPart") then
                v.Material = Enum.Material.SmoothPlastic
                v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then
                v.Transparency = 0.5
            elseif v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Fire") then
                v.Enabled = false
            end
        end
    elseif mode == "Anti Lag Pro" then
        lighting.GlobalShadows = false
        lighting.Brightness = 0.5
        workspace.LevelOfDetail = Enum.LevelOfDetailSetting.Low
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Part") or v:IsA("MeshPart") then
                v.Material = Enum.Material.SmoothPlastic
                v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then
                v.Transparency = 0.7
            elseif v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Fire") then
                v.Enabled = false
            end
        end
        lighting.FogEnd = 9e9
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    elseif mode == "Anti Lag Extreme" then
        lighting.GlobalShadows = false
        lighting.Brightness = 0
        workspace.LevelOfDetail = Enum.LevelOfDetailSetting.Low
        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("Part") or v:IsA("MeshPart") then
                v.Material = Enum.Material.SmoothPlastic
                v.Reflectance = 0
            elseif v:IsA("Decal") or v:IsA("Texture") then
                v.Transparency = 1
            elseif v:IsA("ParticleEmitter") or v:IsA("Smoke") or v:IsA("Fire") then
                v.Enabled = false
            end
        end
        lighting.FogEnd = 9e9
        settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    end
end

-- GUI Setup
local Windows = NothingLibrary.new({
    Title = "VicoX - Blade Ball",
    Description = "Ultimate Auto-Parry, Auto-Spam, and Effects",
    Keybind = Enum.KeyCode.LeftControl,
    Logo = "rbxassetid://18898582662"
})

local TabFrame = Windows:NewTab({
    Title = "Main",
    Description = "Auto-Parry and Auto-Spam Controls",
    Icon = "rbxassetid://7733960981"
})

local AutoSection = TabFrame:NewSection({
    Title = "Parry Settings",
    Icon = "rbxassetid://7743869054",
    Position = "Left"
})

local VisualSection = TabFrame:NewSection({
    Title = "Visual & Effects",
    Icon = "rbxassetid://7743869054",
    Position = "Right"
})

local MiscSection = TabFrame:NewSection({
    Title = "Miscellaneous",
    Icon = "rbxassetid://7743869054",
    Position = "Right"
})

AutoSection:NewToggle({
    Title = "Auto-Parry",
    Default = false,
    Callback = function(state)
        Settings.AutoParryEnabled = state
        print("Auto-Parry:", state)
    end
})

AutoSection:NewToggle({
    Title = "Auto-Spam",
    Default = false,
    Callback = function(state)
        Settings.AutoSpamEnabled = state
        print("Auto-Spam:", state)
    end
})

AutoSection:NewToggle({
    Title = "Cursor-Based Targeting",
    Default = false,
    Callback = function(state)
        Settings.CursorTargeting = state
        print("Cursor-Based Targeting:", state)
    end
})

AutoSection:NewToggle({
    Title = "AI Movement",
    Default = false,
    Callback = function(state)
        Settings.AIEnabled = state
        print("AI Movement:", state)
    end
})

AutoSection:NewSlider({
    Title = "Parry Distance Threshold",
    Min = 0.3,
    Max = 1.0,
    Default = 0.65,
    Callback = function(value)
        Settings.ParryDistanceThreshold = value
        print("Parry Distance Threshold:", value)
    end
})

AutoSection:NewDropdown({
    Title = "Curve Method",
    Data = {"Up", "Right", "Left", "Accelerated", "Backwards", "Random"},
    Default = "Accelerated",
    Callback = function(value)
        Settings.CurveMethod = value
        print("Curve Method:", value)
    end
})

AutoSection:NewButton({
    Title = "Show Parry Count",
    Callback = function()
        notify.new({
            Title = "Parry Count",
            Description = "Current Parry Count: " .. parryCount,
            Duration = 3,
            Icon = "rbxassetid://8997385628"
        })
        print("Current Parry Count: " .. parryCount)
    end
})

VisualSection:NewToggle({
    Title = "Visualizer",
    Default = false,
    Callback = function(state)
        Settings.VisualizerEnabled = state
        print("Visualizer:", state)
        if not state then
            Visualize.Transparency = 1
            Visualize1.Transparency = 1
        end
    end
})

VisualSection:NewToggle({
    Title = "Hit Effect",
    Default = false,
    Callback = function(state)
        Settings.HitEffectEnabled = state
        print("Hit Effect:", state)
    end
})

VisualSection:NewToggle({
    Title = "Hit Sound",
    Default = false,
    Callback = function(state)
        Settings.HitSoundEnabled = state
        print("Hit Sound:", state)
    end
})

VisualSection:NewDropdown({
    Title = "Select Sound",
    Data = {"DC-15X", "Neverlose", "Minecraft", "MinecraftHit2", "Teamfortress Bonk", "Teamfortress Bell"},
    Default = "DC-15X",
    Callback = function(selected)
        if selected == "DC-15X" then
            setHitSound("rbxassetid://936447863")
        elseif selected == "Neverlose" then
            setHitSound("rbxassetid://8679627751")
        elseif selected == "Minecraft" then
            setHitSound("rbxassetid://8766809464")
        elseif selected == "MinecraftHit2" then
            setHitSound("rbxassetid://8458185621")
        elseif selected == "Teamfortress Bonk" then
            setHitSound("rbxassetid://8255306220")
        elseif selected == "Teamfortress Bell" then
            setHitSound("rbxassetid://2868331684")
        end
        Settings.HitSound = selected
        print("Selected Sound:", selected)
    end
})

VisualSection:NewToggle({
    Title = "Self Effect",
    Default = false,
    Callback = function(state)
        Settings.SelfEffectEnabled = state
        print("Self Effect:", state)
    end
})

VisualSection:NewToggle({
    Title = "Trail",
    Default = false,
    Callback = function(state)
        Settings.TrailEnabled = state
        print("Trail:", state)
    end
})

VisualSection:NewToggle({
    Title = "Kill Effect",
    Default = false,
    Callback = function(state)
        Settings.KillEffectEnabled = state
        print("Kill Effect:", state)
    end
})

VisualSection:NewToggle({
    Title = "Shaders",
    Default = false,
    Callback = function(state)
        Settings.ShadersEnabled = state
        print("Shaders:", state)
    end
})

VisualSection:NewToggle({
    Title = "Night Mode",
    Default = false,
    Callback = function(state)
        Settings.NightModeEnabled = state
        print("Night Mode:", state)
    end
})

VisualSection:NewToggle({
    Title = "Spectate Ball",
    Default = false,
    Callback = function(state)
        Settings.SpectateEnabled = state
        print("Spectate Ball:", state)
    end
})

VisualSection:NewSlider({
    Title = "Bloom Intensity",
    Min = 1.0,
    Max = 3.0,
    Default = 2.1,
    Callback = function(value)
        Settings.BloomIntensity = value
        print("Bloom Intensity:", value)
    end
})

VisualSection:NewSlider({
    Title = "Hit Effect Particles",
    Min = 1,
    Max = 10,
    Default = 3,
    Callback = function(value)
        Settings.HitEffectParticles = value
        print("Hit Effect Particles:", value)
    end
})

MiscSection:NewDropdown({
    Title = "Anti Lag",
    Data = {"Disable", "Anti Lag Basic", "Anti Lag Pro", "Anti Lag Extreme"},
    Default = "Disable",
    Callback = function(value)
        Settings.AntiLagMode = value
        applyAntiLag(value)
        print("Anti Lag Mode:", value)
    end
})

MiscSection:NewToggle({
    Title = "Anti-Idle",
    Default = false,
    Callback = function(state)
        Settings.AntiIdleEnabled = state
        print("Anti-Idle:", state)
    end
})

MiscSection:NewToggle({
    Title = "Auto-Rejoin",
    Default = false,
    Callback = function(state)
        Settings.AutoRejoinEnabled = state
        print("Auto-Rejoin:", state)
        if state then
            notify.new({
                Title = "Auto-Rejoin",
                Description = "Rejoining in 5 seconds...",
                Duration = 3,
                Icon = "rbxassetid://8997385628"
            })
            task.wait(5)
            TeleportService:Teleport(game.PlaceId, LocalPlayer)
        end
    end
})

-- Initialization
applyAntiLag("Disable")
notify.new({
    Title = "VicoX Loaded",
    Description = "Ultimate Auto-Parry, Auto-Spam, and Enhanced Features ready!",
    Duration = 5,
    Icon = "rbxassetid://8997385628"
})

print("VicoX Blade Ball Script Initialized")

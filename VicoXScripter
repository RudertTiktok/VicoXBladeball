-- Services
local RobloxReplicatedStorage = game:GetService('RobloxReplicatedStorage')
local RbxAnalyticsService = game:GetService('RbxAnalyticsService')
local ReplicatedStorage = game:GetService('ReplicatedStorage')
local UserInputService = game:GetService('UserInputService')
local NetworkClient = game:GetService('NetworkClient')
local VirtualInputManager = game:GetService('VirtualInputManager')
local TweenService = game:GetService('TweenService')
local VirtualUser = game:GetService('VirtualUser')
local HttpService = game:GetService('HttpService')
local RunService = game:GetService('RunService')
local LogService = game:GetService('LogService')
local Players = game:GetService('Players')
local Debris = game:GetService('Debris')
local Stats = game:GetService('Stats')

-- Wait for game to load
if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- Global auto-parry toggle
getgenv().auto_parry_enabled = false

-- Loading screen GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "LoadingScreen"
screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

local frame = Instance.new("Frame")
frame.Size = UDim2.new(1, 0, 1, 0)
frame.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
frame.BackgroundTransparency = 0.6
frame.Parent = screenGui

local uiGradient = Instance.new("UIGradient")
uiGradient.Parent = frame
uiGradient.Color = ColorSequence.new(Color3.fromRGB(0, 0, 0), Color3.fromRGB(50, 50, 50))
uiGradient.Rotation = 45

local textLabel = Instance.new("TextLabel")
textLabel.Text = "Credit: Rudert and Flezzpe"
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
textLabel.TextSize = 50
textLabel.TextStrokeTransparency = 0.6
textLabel.TextStrokeColor3 = Color3.fromRGB(0, 0, 0)
textLabel.TextWrapped = true
textLabel.Size = UDim2.new(0, 550, 0, 200)
textLabel.Position = UDim2.new(0.5, -250, 0.5, -75)
textLabel.TextXAlignment = Enum.TextXAlignment.Center
textLabel.TextYAlignment = Enum.TextYAlignment.Center
textLabel.Parent = frame

local border = Instance.new("UICorner")
border.CornerRadius = UDim.new(0, 10)
border.Parent = textLabel

local shadow = Instance.new("Frame")
shadow.Size = UDim2.new(1, 6, 1, 6)
shadow.Position = UDim2.new(0, 3, 0, 3)
shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
shadow.BackgroundTransparency = 0.5
shadow.ZIndex = textLabel.ZIndex - 1
shadow.Parent = textLabel

local fadeInTweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out)
local fadeInTween = TweenService:Create(textLabel, fadeInTweenInfo, {TextTransparency = 0, Position = UDim2.new(0.5, -250, 0.5, -75)})

local moveUpTweenInfo = TweenInfo.new(1.5, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
local moveUpTween = TweenService:Create(textLabel, moveUpTweenInfo, {Position = UDim2.new(0.5, -250, 0.5, -150)})

local fadeOutTweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quart, Enum.EasingDirection.In)
local fadeOutTween = TweenService:Create(textLabel, fadeOutTweenInfo, {TextTransparency = 1})

fadeInTween:Play()

fadeInTween.Completed:Connect(function()
    task.wait(1)
    moveUpTween:Play()

    moveUpTween.Completed:Connect(function()
        fadeOutTween:Play()

        fadeOutTween.Completed:Connect(function()
            screenGui:Destroy()
        end)
    end)
end)

-- Initialize NothingLibrary and notify
local NothingLibrary = loadstring(game:HttpGetAsync('https://raw.githubusercontent.com/3345-c-a-t-s-u-s/NOTHING/main/source.lua'))()
local notify = NothingLibrary.Notification()

notify.new({
    Title = "...VicoX Is Fetch...",
    Description = "Welcome to Vico script, I hope you like it ðŸ˜‹..",
    Duration = 6,
    Icon = "rbxassetid://8997385628"
})

-- Local variables
local LocalPlayer = Players.LocalPlayer
local RunTime = workspace.Runtime
local Alive = workspace.Alive
local Dead = workspace.Dead
local is_mobile = UserInputService.TouchEnabled
local interface = { flags = { curve_method = "Linear" }, disconnected = false }
local ConnectionsManager = {}

-- Notification cooldowns
local lastParryNotificationTime = 0
local lastSpamNotificationTime = 0
local notificationCooldown = 5 -- Cooldown in seconds for notifications

-- AutoParry structure
local AutoParry = {
    ball = {
        training_ball_entity = nil,
        client_ball_entity = nil,
        ball_entity = nil,
        properties = {
            aero_dynamic_time = tick(),
            hell_hook_completed = true,
            last_position = Vector3.zero,
            rotation = Vector3.zero,
            position = Vector3.zero,
            last_warping = tick(),
            parry_remote = nil,
            is_curved = false,
            last_tick = tick(),
            auto_spam = false,
            cooldown = false,
            respawn_time = 0,
            parry_range = 0,
            spam_range = 0,
            maximum_speed = 0,
            old_speed = 0,
            parries = 0,
            direction = Vector3.zero,
            distance = 0,
            velocity = Vector3.zero,
            last_hit = 0,
            lerp_radians = 0,
            radians = 0,
            speed = 0,
            dot = 0,
            previous_ping = 0,
        },
    },
    target = {
        current = nil,
        from = nil,
        aim = nil,
    },
    aim = {
        Name = nil,
    },
    entity_properties = {
        server_position = Vector3.zero,
        velocity = Vector3.zero,
        is_moving = false,
        direction = Vector3.zero,
        distance = 0,
        speed = 0,
        dot = 0,
    },
}

-- Player structure
local Player = {
    Entity = {
        properties = {
            sword = '',
            server_position = Vector3.zero,
            velocity = Vector3.zero,
            position = Vector3.zero,
            is_moving = false,
            speed = 0,
            ping = 0,
        },
    },
    properties = {
        grab_animation = nil,
    },
}

local World = {}

-- Utility functions
local function linear_predict(a, b, time_volume)
    return a + (b - a) * time_volume
end

function World:get_pointer()
    local mouse_location = UserInputService:GetMouseLocation()
    local ray = workspace.CurrentCamera:ScreenPointToRay(mouse_location.X, mouse_location.Y, 0)
    return CFrame.lookAt(ray.Origin, ray.Origin + ray.Direction)
end

function AutoParry.get_ball()
    for _, ball in pairs(workspace:WaitForChild("Balls"):GetChildren()) do
        if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
            return ball
        end
    end
    return nil
end

function AutoParry.get_client_ball()
    for _, ball in pairs(workspace:WaitForChild("Balls"):GetChildren()) do
        if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
            return ball
        end
    end
    return nil
end

function getTrainingBall()
    for _, ball in workspace:WaitForChild("TrainingBalls"):GetChildren() do
        if ball:IsA("BasePart") and ball:GetAttribute("realBall") then
            return ball
        end
    end
    return nil
end

function Player:get_aim_entity()
    local closest_entity = nil
    local minimal_dot_product = -math.huge
    local camera_direction = workspace.CurrentCamera and workspace.CurrentCamera.CFrame.LookVector or Vector3.zero

    for _, player in Alive:GetChildren() do
        if not player or player.Name == LocalPlayer.Name or not player:FindFirstChild('HumanoidRootPart') then
            continue
        end

        local entity_direction = (player.HumanoidRootPart.Position - (workspace.CurrentCamera and workspace.CurrentCamera.CFrame.Position or Vector3.zero)).Unit
        local dot_product = camera_direction:Dot(entity_direction)

        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_entity = player
        end
    end

    return closest_entity
end

function Player:get_closest_player_to_cursor()
    local closest_player = nil
    local minimal_dot_product = -math.huge

    for _, player in Alive:GetChildren() do
        if player == LocalPlayer.Character or player.Parent ~= Alive or not player.PrimaryPart then
            continue
        end

        local player_direction = (player.PrimaryPart.Position - (workspace.CurrentCamera and workspace.CurrentCamera.CFrame.Position or Vector3.zero)).Unit
        local pointer = World.get_pointer()
        local dot_product = pointer.LookVector:Dot(player_direction)

        if dot_product > minimal_dot_product then
            minimal_dot_product = dot_product
            closest_player = player
        end
    end

    return closest_player
end

local platform = UserInputService.TouchEnabled and "Android" or "PC"
print("Platform detected:", platform)

function AutoParry.perform_grab_animation()
    local animation = ReplicatedStorage.Shared.SwordAPI.Collection.Default:FindFirstChild('GrabParry')
    local currently_equipped = Player.Entity.properties.sword

    if not currently_equipped or currently_equipped == 'Titan Blade' or not animation then
        return
    end

    local sword_data = ReplicatedStorage.Shared.ReplicatedInstances.Swords.GetSword:Invoke(currently_equipped)

    if not sword_data or not sword_data['AnimationType'] then
        return
    end

    local character = LocalPlayer.Character
    if not character or not character:FindFirstChild('Humanoid') then
        return
    end

    for _, object in ReplicatedStorage.Shared.SwordAPI.Collection:GetChildren() do
        if object.Name ~= sword_data['AnimationType'] then
            continue
        end

        if not (object:FindFirstChild('GrabParry') or object:FindFirstChild('Grab')) then
            continue
        end

        local sword_animation_type = object:FindFirstChild('GrabParry') and 'GrabParry' or 'Grab'
        animation = object[sword_animation_type]
    end

    if animation then
        Player.properties.grab_animation = character.Humanoid:LoadAnimation(animation)
        Player.properties.grab_animation:Play()
    end
end

function AutoParry.perform_parry()
    local ball_properties = AutoParry.ball.properties
    
    if ball_properties.cooldown and not ball_properties.auto_spam then
        return
    end

    ball_properties.parries += 1
    ball_properties.last_hit = tick()

    local camera = workspace.CurrentCamera
    local camera_direction = camera and camera.CFrame.Position or Vector3.zero
    local direction = camera and camera.CFrame or CFrame.new()
    local target_position = AutoParry.entity_properties.server_position

    if not ball_properties.auto_spam then
        AutoParry.perform_grab_animation()
        ball_properties.cooldown = true

        local current_curve = interface.flags.curve_method

        if current_curve == 'Linear' then
            direction = CFrame.new(LocalPlayer.Character and LocalPlayer.Character.PrimaryPart.Position or Vector3.zero, target_position)
        elseif current_curve == 'Backwards' then
            direction = CFrame.new(camera_direction, (camera_direction + (-camera.CFrame.LookVector * 10000)) + Vector3.new(0, 1000, 0))
        elseif current_curve == 'Random' then
            direction = CFrame.new(LocalPlayer.Character and LocalPlayer.Character.PrimaryPart.Position or Vector3.zero, Vector3.new(math.random(-1000, 1000), math.random(-350, 1000), math.random(-1000, 1000)))
        elseif current_curve == 'Accelerated' then
            direction = CFrame.new(LocalPlayer.Character and LocalPlayer.Character.PrimaryPart.Position or Vector3.zero, target_position + Vector3.new(0, 150, 0))
        end
    else
        direction = CFrame.new(camera_direction, target_position + Vector3.new(0, 60, 0))
    end

    if LocalPlayer.Character and workspace.CurrentCamera then
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0) -- Press left mouse button
        task.wait(0.1)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0) -- Release left mouse button

        if tick() - lastParryNotificationTime >= notificationCooldown then
            notify.new({
                Title = "Parry",
                Description = "Parry attempted!",
                Duration = 1,
                Icon = "rbxassetid://8997385628"
            })
            lastParryNotificationTime = tick()
        end
    end

    task.delay(0.25, function()
        if ball_properties.parries > 0 then
            ball_properties.parries -= 1
        end
    end)
end

-- UI setup
local Windows = NothingLibrary.new({
    Title = "Vico - NeuX",
    Description = "Vico - Blade Ball - Test",
    Keybind = Enum.KeyCode.LeftControl,
    Logo = 'http://www.roblox.com/asset/?id=18898582662'
})

local TabFrame = Windows:NewTab({
    Title = "Main",
    Description = "very cool and awesome",
    Icon = "rbxassetid://7733960981"
})

do
    local AutoSection = TabFrame:NewSection({
        Title = "Parry",
        Icon = "rbxassetid://7743869054",
        Position = "Left"
    })

    AutoSection:NewToggle({
        Title = "AutoParry",
        Default = false,
        Callback = function(state)
            getgenv().auto_parry_enabled = state
            print("Autoparry:", state)
        end
    })

    AutoSection:NewToggle({
        Title = "Rotation",
        Default = false,
        Callback = function(state)
            auto_parry_rotation_enabled = state
            print("Auto Parry Rotation:", state)
        end
    })

    AutoSection:NewSlider({
        Title = "Acuity",
        Min = 1,
        Max = 10,
        Default = 5,
        Callback = function(value)
            auto_parry_rotation_acuity_value = value
            print("Auto Parry Rotation Acuity:", value)
        end
    })

    AutoSection:NewDropdown({
        Title = "Curve Method",
        Data = {"Accelerated", "Backwards", "Linear", "Camera", "Random"},
        Default = "Linear",
        Callback = function(value)
            interface.flags.curve_method = value
            print("Selected Curve Method:", value)
        end
    })
end

-- Idle handling
LocalPlayer.Idled:Connect(function()
    VirtualUser:CaptureController()
    VirtualUser:ClickButton2(Vector2.zero)
end)

function AutoParry.reset()
    local ball_properties = AutoParry.ball.properties
    ball_properties.is_curved = false
    ball_properties.auto_spam = false
    ball_properties.cooldown = false
    ball_properties.maximum_speed = 0
    ball_properties.parries = 0
    AutoParry.entity_properties.server_position = Vector3.zero
    AutoParry.target.current = nil
    AutoParry.target.from = nil
end

ReplicatedStorage.Remotes.PlrHellHooked.OnClientEvent:Connect(function(hooker)
    if hooker and hooker.Name == LocalPlayer.Name then
        AutoParry.ball.properties.hell_hook_completed = true
    else
        AutoParry.ball.properties.hell_hook_completed = false
    end
end)

ReplicatedStorage.Remotes.PlrHellHookCompleted.OnClientEvent:Connect(function()
    AutoParry.ball.properties.hell_hook_completed = true
end)

function AutoParry.is_curved()
    local target = AutoParry.target.current
    if not target or not target.PrimaryPart then
        return false
    end

    local ball_properties = AutoParry.ball.properties
    local current_target = target.Name

    if target.PrimaryPart:FindFirstChild('MaxShield') and current_target ~= LocalPlayer.Name and ball_properties.distance < 50 then
        return false
    end

    if AutoParry.ball.ball_entity and AutoParry.ball.ball_entity:FindFirstChild('TimeHole1') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
        ball_properties.auto_spam = false
        return false
    end

    if AutoParry.ball.ball_entity and AutoParry.ball.ball_entity:FindFirstChild('WEMAZOOKIEGO') and current_target ~= LocalPlayer.Name and ball_properties.distance < 100 then
        return false
    end

    if AutoParry.ball.ball_entity and AutoParry.ball.ball_entity:FindFirstChild('At2') and ball_properties.speed <= 0 then
        return true
    end

    if AutoParry.ball.ball_entity and AutoParry.ball.ball_entity:FindFirstChild('AeroDynamicSlashVFX') then
        Debris:AddItem(AutoParry.ball.ball_entity.AeroDynamicSlashVFX, 0)
        ball_properties.auto_spam = false
        ball_properties.aero_dynamic_time = tick()
    end

    if RunTime:FindFirstChild('Tornado') then
        if ball_properties.distance > 5 and (tick() - ball_properties.aero_dynamic_time) < (RunTime.Tornado:GetAttribute("TornadoTime") or 1) + 0.314159 then
            return true
        end
    end

    if not ball_properties.hell_hook_completed and target.Name == LocalPlayer.Name and ball_properties.distance > 5 - math.random() then
        return true
    end

    local ball_direction = ball_properties.velocity.Unit
    local ball_speed = ball_properties.speed
    local speed_threshold = math.min(ball_speed / 100, 40)
    local angle_threshold = 40 * math.max(ball_properties.dot, 0)
    local player_ping = Player.Entity.properties.ping
    local accurate_direction = ball_properties.velocity.Unit
    local direction_difference = (accurate_direction - ball_properties.velocity).Unit
    local accurate_dot = ball_properties.direction:Dot(direction_difference)
    local dot_difference = ball_properties.dot - accurate_dot
    local dot_threshold = 0.5 - player_ping / 1000
    local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)
    local enough_speed = ball_properties.maximum_speed > 100
    local ball_distance_threshold = 15 - math.min(ball_properties.distance / 1000, 15) + angle_threshold + speed_threshold

    if enough_speed and reach_time > player_ping / 10 then
        ball_distance_threshold = math.max(ball_distance_threshold - 15, 15)
    end

    if ball_properties.distance < ball_distance_threshold then
        return false
    end

    if dot_difference < dot_threshold then
        return true
    end

    if ball_properties.lerp_radians < 0.018 then
        ball_properties.last_curve_position = ball_properties.position
        ball_properties.last_warping = tick()
    end

    if (tick() - ball_properties.last_warping) < (reach_time / 1.6) then
        return true
    end

    return ball_properties.dot < dot_threshold
end

function AutoParry:is_spam()
    local target = AutoParry.target.current
    if not target then
        return false
    end

    local ball_properties = AutoParry.ball.properties
    local old_from_target = AutoParry.target.from ~= LocalPlayer.Character and AutoParry.target.from or old_from_target
    if ball_properties.parries < 3 and AutoParry.target.from == old_from_target then
        return false
    end

    local player_ping = Player.Entity.properties.ping
    local distance_threshold = 18 + (player_ping / 80)
    local reach_time = ball_properties.distance / ball_properties.maximum_speed - (player_ping / 1000)

    if (tick() - ball_properties.last_hit) < 0.4 then
        ball_properties.parries = 1
        return false
    end

    if (tick() - ball_properties.last_hit) > 0.8 and AutoParry.entity_properties.distance > distance_threshold and ball_properties.parries < 2 then
        ball_properties.parries = 0
        return false
    end

    if ball_properties.lerp_radians > 0.028 then
        if ball_properties.parries > 3 then
            ball_properties.parries = 1
        end
        return false
    end

    if (tick() - ball_properties.last_warping) < (reach_time / 1.5) and AutoParry.entity_properties.distance > distance_threshold and ball_properties.parries < 4 then
        if ball_properties.parries > 3 then
            ball_properties.parries = 1
        end
        return false
    end

    if math.abs(ball_properties.speed - ball_properties.old_speed) < 5.2 and AutoParry.entity_properties.distance > distance_threshold and ball_properties.speed < 60 and ball_properties.parries < 3 then
        if ball_properties.parries > 3 then
            ball_properties.parries = 0
        end
        return false
    end

    if ball_properties.speed < 10 then
        ball_properties.parries = 1
        return false
    end

    if ball_properties.maximum_speed < ball_properties.speed and AutoParry.entity_properties.distance > distance_threshold then
        ball_properties.parries = 1
        return false
    end

    if AutoParry.entity_properties.distance > ball_properties.spam_range and AutoParry.entity_properties.distance > distance_threshold then
        if ball_properties.parries > 2 then
            ball_properties.parries = 1
        end
        return false
    end

    if ball_properties.distance > ball_properties.spam_range and AutoParry.entity_properties.distance > distance_threshold then
        if ball_properties.parries > 2 then
            ball_properties.parries = 2
        end
        return false
    end

    local distance_to_last_position = LocalPlayer:DistanceFromCharacter(ball_properties.last_position)
    if distance_to_last_position > ball_properties.spam_range and AutoParry.entity_properties.distance > distance_threshold then
        if ball_properties.parries > 4 then
            ball_properties.parries = 2
        end
        return false
    end

    if ball_properties.distance > ball_properties.spam_range and ball_properties.distance > distance_threshold then
        if ball_properties.parries > 3 then
            ball_properties.parries = 2
        end
        return false
    end

    if AutoParry.entity_properties.distance < 7 then
        if ball_properties.parries < 2 then
            ball_properties.parries = 1
            return false
        end
    end

    if AutoParry.entity_properties.distance < 4 then
        if (tick() - ball_properties.last_hit) > 0.4 then
            if ball_properties.parries < 3 then
                ball_properties.parries = 1
                return false
            end
        end
    end

    if ball_properties.speed > 20 and AutoParry.entity_properties.distance < 10 then
        if ball_properties.parries < 2 then
            ball_properties.parries = 1
            return false
        end
    end

    if ball_properties.target == LocalPlayer.Character then
        if AutoParry.entity_properties.distance < 7 then
            if ball_properties.parries < 3 then
                ball_properties.parries = 1
                return false
            end
        end
    end

    if AutoParry.entity_properties.distance < 5 then
        if ball_properties.speed < 13 then
            local movement_factor = math.abs(ball_properties.speed - ball_properties.old_speed)
            if movement_factor < 2 and ball_properties.parries < 2 then
                ball_properties.parries = 2
                return false
            end
        else
            if ball_properties.parries < 3 then
                ball_properties.parries = 1
                return false
            end
        end
    end

    if ball_properties.speed < 8 and ball_properties.parries < 2 then
        ball_properties.parries = 1
        return false
    end

    if AutoParry.entity_properties.distance < 4 and ball_properties.target == LocalPlayer.Character then
        if ball_properties.parries < 3 then
            ball_properties.parries = 1
            return false
        end
    end

    if AutoParry.entity_properties.distance < 3 and ball_properties.speed > 15 then
        local ball_distance_to_target = ball_properties.distance - AutoParry.entity_properties.distance
        if ball_distance_to_target < 10 and ball_properties.parries < 3 then
            ball_properties.parries = 1
            return false
        end
    end

    return true
end

RunService:BindToRenderStep('server_position_simulation', 1, function()
    local ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
    if not LocalPlayer.Character or not LocalPlayer.Character.PrimaryPart then
        return
    end

    local old_position = LocalPlayer.Character.PrimaryPart.Position
    task.delay(ping / 1000, function()
        Player.Entity.properties.server_position = old_position
    end)
end)

RunService.PreSimulation:Connect(function()
    NetworkClient:SetOutgoingKBPSLimit(math.huge)
    local character = LocalPlayer.Character
    if not character or not character.PrimaryPart then
        return
    end

    local player_properties = Player.Entity.properties
    player_properties.sword = character:GetAttribute('CurrentlyEquippedSword') or ''
    player_properties.ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
    player_properties.velocity = character.PrimaryPart.AssemblyLinearVelocity
    player_properties.speed = player_properties.velocity.Magnitude
    player_properties.is_moving = player_properties.speed > 30
end)

AutoParry.ball.ball_entity = AutoParry.get_ball()
AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()

RunService.PreSimulation:Connect(function()
    local ball = AutoParry.ball.ball_entity
    if not ball then
        return
    end

    local zoomies = ball:FindFirstChild('zoomies')
    local ball_properties = AutoParry.ball.properties

    ball_properties.position = ball.Position
    ball_properties.velocity = zoomies and zoomies.VectorVelocity or ball.AssemblyLinearVelocity
    ball_properties.distance = (Player.Entity.properties.server_position - ball_properties.position).Magnitude
    ball_properties.speed = ball_properties.velocity.Magnitude
    ball_properties.direction = (Player.Entity.properties.server_position - ball_properties.position).Unit
    ball_properties.dot = ball_properties.direction:Dot(ball_properties.velocity.Unit)
    ball_properties.radians = math.rad(math.asin(ball_properties.dot))
    ball_properties.lerp_radians = linear_predict(ball_properties.lerp_radians, ball_properties.radians, 0.8)

    if not (ball_properties.lerp_radians < 0) and not (ball_properties.lerp_radians > 0) then
        ball_properties.lerp_radians = 0.027
    end

    ball_properties.maximum_speed = math.max(ball_properties.speed, ball_properties.maximum_speed)
    AutoParry.target.aim = is_mobile and Player.get_aim_entity() or Player.get_closest_player_to_cursor()

    if ball:GetAttribute('from') then
        AutoParry.target.from = Alive:FindFirstChild(ball:GetAttribute('from'))
    end

    AutoParry.target.current = Alive:FindFirstChild(ball:GetAttribute('target'))
    if not AutoParry.target.current then
        return
    end

    ball_properties.rotation = ball_properties.position
    if AutoParry.target.current.Name == LocalPlayer.Name then
        ball_properties.rotation = AutoParry.target.aim and AutoParry.target.aim.PrimaryPart and AutoParry.target.aim.PrimaryPart.Position or ball_properties.position
        return
    end

    local target_server_position = AutoParry.target.current.PrimaryPart.Position
    local target_velocity = AutoParry.target.current.PrimaryPart.AssemblyLinearVelocity
    AutoParry.entity_properties.server_position = target_server_position
    AutoParry.entity_properties.velocity = target_velocity
    AutoParry.entity_properties.distance = LocalPlayer:DistanceFromCharacter(target_server_position)
    AutoParry.entity_properties.direction = (Player.Entity.properties.server_position - target_server_position).Unit
    AutoParry.entity_properties.speed = target_velocity.Magnitude
    AutoParry.entity_properties.is_moving = target_velocity.Magnitude > 0.1
    AutoParry.entity_properties.dot = AutoParry.entity_properties.is_moving and math.max(AutoParry.entity_properties.direction:Dot(target_velocity.Unit), 0) or 0
end)

local is_respawned = false

function ConnectionsManager:disconnect(key)
    if self[key] then
        self[key]:Disconnect()
        self[key] = nil
    end
end

workspace.Balls.ChildRemoved:Connect(function(child)
    is_respawned = false
    if child == AutoParry.ball.ball_entity then
        AutoParry.ball.ball_entity = nil
        AutoParry.ball.client_ball_entity = nil
        ConnectionsManager:disconnect('on_target_change')
        AutoParry.reset()
    end
end)

workspace.Balls.ChildAdded:Connect(function()
    if is_respawned then
        return
    end

    is_respawned = true
    local ball_properties = AutoParry.ball.properties
    ball_properties.respawn_time = tick()

    AutoParry.ball.ball_entity = AutoParry.get_ball()
    AutoParry.ball.client_ball_entity = AutoParry.get_client_ball()

    if AutoParry.ball.ball_entity then
        ConnectionsManager['on_target_change'] = AutoParry.ball.ball_entity:GetAttributeChangedSignal('target'):Connect(function()
            local target = AutoParry.ball.ball_entity:GetAttribute('target')
            ball_properties.cooldown = false
            if target ~= LocalPlayer.Name then
                ball_properties.old_speed = ball_properties.speed
                ball_properties.last_position = ball_properties.position
                ball_properties.parries += 1
                task.delay(0.25, function()
                    if ball_properties.parries > 0 then
                        ball_properties.parries -= 1
                    end
                end)
            end
        end)
    end
end)

RunService.PreSimulation:Connect(function()
    if AutoParry.ball.properties.auto_spam then
        AutoParry.perform_parry()
    end
end)

ReplicatedStorage.Remotes.ParrySuccessAll.OnClientEvent:Connect(function(slash, root)
    task.spawn(function()
        if root.Parent and root.Parent ~= LocalPlayer.Character and root.Parent.Parent ~= Alive then
            return
        end
        AutoParry.ball.properties.cooldown = false
    end)

    if AutoParry.ball.properties.auto_spam then
        AutoParry.perform_parry()
    end
end)

local autoparryvar
autoparryvar = RunService.PostSimulation:Connect(function()
    if not getgenv().auto_parry_enabled then
        AutoParry.reset()
        return
    end

    local Character = LocalPlayer.Character
    if not Character or Character.Parent == Dead or not AutoParry.ball.ball_entity then
        AutoParry.reset()
        return
    end

    local ball_properties = AutoParry.ball.properties
    ball_properties.is_curved = AutoParry.is_curved()
    local current_ping = Player.Entity.properties.ping
    local previous_ping = ball_properties.previous_ping or current_ping
    local ping_spike = math.abs(current_ping - previous_ping) > 50
    ball_properties.previous_ping = current_ping

    local ping_threshold = math.clamp(current_ping / 10, 10, 16)
    local spam_accuracity = ball_properties.maximum_speed / 7.5 + ping_threshold
    local parry_accuracity = ball_properties.maximum_speed / 11.3 + ping_threshold

    ball_properties.spam_range = math.min(ping_threshold + ball_properties.speed / math.pi * 4, 90)
    ball_properties.parry_range = ping_threshold / 10 + ball_properties.speed / math.pi * 2

    if Player.Entity.properties.sword == 'Titan Blade' then
        ball_properties.parry_range += 11
        ball_properties.spam_range += 2
    end

    local distance_to_last_position = LocalPlayer:DistanceFromCharacter(ball_properties.last_position)

    if ping_spike then
        ball_properties.spam_range = ball_properties.spam_range * 1.5
        ball_properties.parry_range = ball_properties.parry_range * 1.5
    end

    if ball_properties.auto_spam and AutoParry.target.current then
        ball_properties.auto_spam = AutoParry:is_spam()
        if ball_properties.auto_spam and tick() - lastSpamNotificationTime >= notificationCooldown then
            notify.new({
                Title = "Spam Detected",
                Description = "Auto-spam mode activated!",
                Duration = 1,
                Icon = "rbxassetid://8997385628"
            })
            lastSpamNotificationTime = tick()
        end
    end

    if ball_properties.auto_spam then
        return
    end

    if AutoParry.target.current and AutoParry.target.current.Name == LocalPlayer.Name then
        ball_properties.auto_spam = AutoParry:is_spam()
        if ball_properties.auto_spam and tick() - lastSpamNotificationTime >= notificationCooldown then
            notify.new({
                Title = "Spam Detected",
                Description = "Auto-spam mode activated!",
                Duration = 1,
                Icon = "rbxassetid://8997385628"
            })
            lastSpamNotificationTime = tick()
        end
    end

    local pings = Stats.Network.ServerStatsItem["Data Ping"]:GetValue() / 10
    local pingset = 100

    if ping_spike or pings > pingset or ball_properties.is_curved or (AutoParry.target.current and AutoParry.target.current ~= LocalPlayer.Character) then
        if pings > pingset then
            return
        end
    end

    if ball_properties.distance > ball_properties.parry_range and ball_properties.distance > parry_accuracity then
        return
    end

    AutoParry.perform_parry()

    task.spawn(function()
        repeat
            RunService.PreSimulation:Wait()
        until (tick() - ball_properties.last_hit) > 1 - (ping_threshold / 100)
        ball_properties.cooldown = false
    end)
end)

-- Connections management
function ConnectionsManager:abadone()
    for key, connection in pairs(self) do
        if typeof(connection) == 'RBXScriptConnection' then
            connection:Disconnect()
            self[key] = nil
        end
    end
end

ConnectionsManager['controller'] = RunService.Heartbeat:Connect(function()
    if interface.disconnected then
        ConnectionsManager:abadone()
    end
end)

-- Ping notification
task.spawn(function()
    local player_ping = Stats.Network.ServerStatsItem['Data Ping']:GetValue()
    if player_ping > 100 and player_ping < 200 then
        notify.new({
            Title = "[Warning]",
            Description = "Low connection speed, delays may occur.",
            Duration = 5,
            Icon = "rbxassetid://8997385628"
        })
    elseif player_ping >= 200 then
        notify.new({
            Title = "[Warning]",
            Description = "Critically slow connection speed, delays ensured.",
            Duration = 5,
            Icon = "rbxassetid://8997385628"
        })
    end
end)

-- Performance optimization
local function optimizePerformance()
    game:GetService("Workspace").StreamingEnabled = true
    settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
    game:GetService("Lighting").GlobalShadows = false
    game:GetService("Lighting").Brightness = 2
    game:GetService("Lighting").OutdoorAmbient = Color3.fromRGB(0, 0, 0)
    game:GetService("UserInputService").MouseDeltaSensitivity = 0.5

    local Workspace = game:GetService("Workspace")
    Workspace.StreamingEnabled = true
    Workspace:SetAttribute("StreamedInDistance", 1000)

    local lighting = game:GetService("Lighting")
    lighting.FogStart = 10000
    lighting.FogEnd = 20000
end

optimizePerformance()

print("All Done Initialization:", platform)
